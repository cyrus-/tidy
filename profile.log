SCRIPT  /usr/share/vim/vim80/syntax/syntax.vim
Sourced 1 time
Total time:   0.465556
 Self time:   0.000465

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000014 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000007 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
                            endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1              0.000131 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000004 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
    1              0.000000 else
                              filetype on
                              let s:did_ft = 0
                            endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000002 augroup syntaxset
    1              0.000005   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000001 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.001787   0.000225 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
                              doautoall filetypedetect BufRead
                            endif

SCRIPT  /usr/share/vim/vim80/syntax/synload.vim
Sourced 1 time
Total time:   0.463522
 Self time:   0.000245

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2012 Sep 25
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000005 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    1              0.000006 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000003 if exists("colors_name")
    1              0.000114   exe "colors " . colors_name
    1              0.000003 else
                              runtime! syntax/syncolor.vim
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000006 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000004 au! Syntax
                            
    1              0.000007 au Syntax *		call s:SynSet()
                            
    1              0.000003 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000019 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000005 if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
                              execute "source " . mysyntaxfile
                            endif
                            
                            " Restore 'cpoptions'
    1              0.000007 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim80/syntax/syncolor.vim
Sourced 3 times
Total time:   0.000750
 Self time:   0.000750

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    3              0.000025 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    2              0.000037   command -nargs=* SynColor hi <args>
    2              0.000011   command -nargs=* SynLink hi link <args>
    2              0.000002 else
    1              0.000001   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000004     command -nargs=* SynColor hi <args>
    1              0.000005     command -nargs=* SynLink hi! link <args>
    1              0.000001   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    1              0.000001 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    3              0.000006 if &background == "dark"
    3              0.000043   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    3              0.000021   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    3              0.000027   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    3              0.000021   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    3              0.000021   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    3              0.000020   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    3              0.000020   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    3              0.000018   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    3              0.000020   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    3              0.000003 else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            endif
    3              0.000021 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    3              0.000021 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    3              0.000015 SynLink String		Constant
    3              0.000012 SynLink Character	Constant
    3              0.000013 SynLink Number		Constant
    3              0.000011 SynLink Boolean		Constant
    3              0.000012 SynLink Float		Number
    3              0.000012 SynLink Function	Identifier
    3              0.000012 SynLink Conditional	Statement
    3              0.000011 SynLink Repeat		Statement
    3              0.000011 SynLink Label		Statement
    3              0.000011 SynLink Operator	Statement
    3              0.000011 SynLink Keyword		Statement
    3              0.000012 SynLink Exception	Statement
    3              0.000012 SynLink Include		PreProc
    3              0.000018 SynLink Define		PreProc
    3              0.000012 SynLink Macro		PreProc
    3              0.000010 SynLink PreCondit	PreProc
    3              0.000012 SynLink StorageClass	Type
    3              0.000010 SynLink Structure	Type
    3              0.000012 SynLink Typedef		Type
    3              0.000012 SynLink Tag		Special
    3              0.000012 SynLink SpecialChar	Special
    3              0.000012 SynLink Delimiter	Special
    3              0.000012 SynLink SpecialComment	Special
    3              0.000010 SynLink Debug		Special
                            
    3              0.000005 delcommand SynColor
    3              0.000006 delcommand SynLink

SCRIPT  /usr/share/vim/vim80/colors/slate.vim
Sourced 1 time
Total time:   0.232624
 Self time:   0.231835

count  total (s)   self (s)
                            "%% SiSU Vim color file
                            " Slate Maintainer: Ralph Amissah <ralph@amissah.com>
                            " (originally looked at desert Hans Fugal <hans@fugal.net> http://hans.fugal.net/vim/colors/desert.vim (2003/05/06)
    1              0.000012 :set background=dark
    1              0.230358 :highlight clear
    1              0.000003 if version > 580
    1              0.000387  hi clear
    1              0.000003  if exists("syntax_on")
    1              0.000095  syntax reset
    1              0.000001  endif
    1              0.000001 endif
    1              0.000005 let colors_name = "slate"
    1              0.000156 :hi Normal guifg=White guibg=grey15
    1              0.000009 :hi Cursor guibg=khaki guifg=slategrey
    1              0.000005 :hi VertSplit guibg=#c2bfa5 guifg=grey40 gui=none cterm=reverse
    1              0.000005 :hi Folded guibg=black guifg=grey40 ctermfg=grey ctermbg=darkgrey
    1              0.000008 :hi FoldColumn guibg=black guifg=grey20 ctermfg=4 ctermbg=7
    1              0.000005 :hi IncSearch guifg=green guibg=black cterm=none ctermfg=yellow ctermbg=green
    1              0.000005 :hi ModeMsg guifg=goldenrod cterm=none ctermfg=brown
    1              0.000004 :hi MoreMsg guifg=SeaGreen ctermfg=darkgreen
    1              0.000009 :hi NonText guifg=RoyalBlue guibg=grey15 cterm=bold ctermfg=blue
    1              0.000005 :hi Question guifg=springgreen ctermfg=green
    1              0.000007 :hi Search guibg=peru guifg=wheat cterm=none ctermfg=grey ctermbg=blue
    1              0.000005 :hi SpecialKey guifg=yellowgreen ctermfg=darkgreen
    1              0.000005 :hi StatusLine guibg=#c2bfa5 guifg=black gui=none cterm=bold,reverse
    1              0.000004 :hi StatusLineNC guibg=#c2bfa5 guifg=grey40 gui=none cterm=reverse
    1              0.000006 :hi Title guifg=gold gui=bold cterm=bold ctermfg=yellow
    1              0.000004 :hi Statement guifg=CornflowerBlue ctermfg=lightblue
    1              0.000006 :hi Visual gui=none guifg=khaki guibg=olivedrab cterm=reverse
    1              0.000005 :hi WarningMsg guifg=salmon ctermfg=1
    1              0.000004 :hi String guifg=SkyBlue ctermfg=darkcyan
    1              0.000004 :hi Comment term=bold ctermfg=11 guifg=grey40
    1              0.000004 :hi Constant guifg=#ffa0a0 ctermfg=brown
    1              0.000005 :hi Special guifg=darkkhaki ctermfg=brown
    1              0.000004 :hi Identifier guifg=salmon ctermfg=red
    1              0.000004 :hi Include guifg=red ctermfg=red
    1              0.000004 :hi PreProc guifg=red guibg=white ctermfg=red
    1              0.000004 :hi Operator guifg=Red ctermfg=Red
    1              0.000005 :hi Define guifg=gold gui=bold ctermfg=yellow
    1              0.000004 :hi Type guifg=CornflowerBlue ctermfg=2
    1              0.000004 :hi Function guifg=navajowhite ctermfg=brown
    1              0.000003 :hi Structure guifg=green ctermfg=green
    1              0.000007 :hi LineNr guifg=grey50 ctermfg=3
    1              0.000003 :hi Ignore guifg=grey40 cterm=bold ctermfg=7
    1              0.000007 :hi Todo guifg=orangered guibg=yellow2
    1              0.000003 :hi Directory ctermfg=darkcyan
    1              0.000005 :hi ErrorMsg cterm=bold guifg=White guibg=Red cterm=bold ctermfg=7 ctermbg=1
    1              0.000003 :hi VisualNOS cterm=bold,underline
    1              0.000003 :hi WildMenu ctermfg=0 ctermbg=3
    1              0.000003 :hi DiffAdd ctermbg=4
    1              0.000003 :hi DiffChange ctermbg=5
    1              0.000003 :hi DiffDelete cterm=bold ctermfg=4 ctermbg=6
    1              0.000004 :hi DiffText cterm=bold ctermbg=1
    1              0.000003 :hi Underlined cterm=underline ctermfg=5
    1              0.000004 :hi Error guifg=White guibg=Red cterm=bold ctermfg=7 ctermbg=1
    1              0.000006 :hi SpellErrors guifg=White guibg=Red cterm=bold ctermfg=7 ctermbg=1

SCRIPT  /home/cyrus/.vim/bundle/nerdtree/syntax/nerdtree.vim
Sourced 2 times
Total time:   0.000765
 Self time:   0.000765

count  total (s)   self (s)
                            let s:tree_up_dir_line = '.. (up a dir)'
    2              0.000015 syn match NERDTreeIgnore #\~#
    2              0.000009 syn match NERDTreeIgnore #\[RO\]#
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    2              0.000018 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "quickhelp syntax elements
    2              0.000014 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    2              0.000009 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    2              0.000008 syn match NERDTreeHelpTitle #" .*\~#ms=s+2,me=e-1
    2              0.000007 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    2              0.000007 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    2              0.000010 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    2              0.000029 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    2              0.000016 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    2              0.000011 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    2              0.000012 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighing for directory nodes and file nodes
    2              0.000010 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    2              0.000004 if g:NERDTreeDirArrows
    2              0.000016     syn match NERDTreeClosable #▾# containedin=NERDTreeDir,NERDTreeFile
    2              0.000013     syn match NERDTreeOpenable #▸# containedin=NERDTreeDir,NERDTreeFile
                            
    2              0.000010     syn match NERDTreeDir #[^▾▸ ].*/#
    2              0.000019     syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
    2              0.000026     syn match NERDTreeFile  #^[^"\.▾▸] *[^▾▸]*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile
                            
                                "highlighting for readonly files
    2              0.000020     syn match NERDTreeRO # *\zs.*\ze \[RO\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile
                            
    2              0.000012     syn match NERDTreeFlags #^ *\zs\[.\]# containedin=NERDTreeFile
    2              0.000011     syn match NERDTreeFlags #\[.\]# containedin=NERDTreeDir
    2              0.000002 else
                                "highlighting for the ~/+ symbols for the directory nodes
                                syn match NERDTreeClosable #\~\<#
                                syn match NERDTreeClosable #\~\.#
                                syn match NERDTreeOpenable #+\<#
                                syn match NERDTreeOpenable #+\.#he=e-1
                            
                                "highlighting for the tree structural parts
                                syn match NERDTreePart #|#
                                syn match NERDTreePart #`#
                                syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart
                            
                                syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeOpenable,NERDTreeClosable
                                syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreePartFile,NERDTreeBookmark
                                syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
                                syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
                            
                                "highlighting for readonly files
                                syn match NERDTreeRO #|-.*\[RO\]#he=e-5 contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreePart,NERDTreePartFile
                            
                                syn match NERDTreeFlags #-\[.\]# containedin=NERDTreeFile,NERDTreePartFile
                                syn match NERDTreeFlags #[+~]\zs\[.\]# containedin=NERDTreeDir
                            endif
                            
    2              0.000009 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    2              0.000008 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    2              0.000008 syn match NERDTreeBookmarksLeader #^>#
    2              0.000012 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    2              0.000011 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    2              0.000016 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    2              0.000009 hi def link NERDTreePart Special
    2              0.000006 hi def link NERDTreePartFile Type
    2              0.000006 hi def link NERDTreeExecFile Title
    2              0.000006 hi def link NERDTreeDirSlash Identifier
                            
    2              0.000006 hi def link NERDTreeBookmarksHeader statement
    2              0.000005 hi def link NERDTreeBookmarksLeader ignore
    2              0.000006 hi def link NERDTreeBookmarkName Identifier
    2              0.000006 hi def link NERDTreeBookmark normal
                            
    2              0.000006 hi def link NERDTreeHelp String
    2              0.000006 hi def link NERDTreeHelpKey Identifier
    2              0.000006 hi def link NERDTreeHelpCommand Identifier
    2              0.000004 hi def link NERDTreeHelpTitle Macro
    2              0.000006 hi def link NERDTreeToggleOn Question
    2              0.000006 hi def link NERDTreeToggleOff WarningMsg
                            
    2              0.000004 hi def link NERDTreeLinkTarget Type
    2              0.000006 hi def link NERDTreeLinkFile Macro
    2              0.000004 hi def link NERDTreeLinkDir Macro
                            
    2              0.000006 hi def link NERDTreeDir Directory
    2              0.000009 hi def link NERDTreeUp Directory
    2              0.000005 hi def link NERDTreeFile Normal
    2              0.000005 hi def link NERDTreeCWD Statement
    2              0.000006 hi def link NERDTreeOpenable Title
    2              0.000005 hi def link NERDTreeClosable Title
    2              0.000006 hi def link NERDTreeIgnore ignore
    2              0.000005 hi def link NERDTreeRO WarningMsg
    2              0.000006 hi def link NERDTreeBookmark Statement
    2              0.000006 hi def link NERDTreeFlags Number
                            
    2              0.000006 hi def link NERDTreeCurrentNode Search

SCRIPT  /home/cyrus/.vim/bundle/pytest.vim/ftplugin/python/pytest.vim
Sourced 2 times
Total time:   0.001560
 Self time:   0.001560

count  total (s)   self (s)
                            " File:        pytest.vim
                            " Description: Runs the current test Class/Method/Function/File with
                            "              py.test
                            " Maintainer:  Alfredo Deza <alfredodeza AT gmail.com>
                            " License:     MIT
                            "============================================================================
                            
                            
    2              0.000018 if exists("g:loaded_pytest") || &cp
                              finish
                            endif
                            
                            
                            " Global variables for registering next/previous error
    2              0.000008 let g:pytest_session_errors    = {}
    2              0.000006 let g:pytest_session_error     = 0
    2              0.000005 let g:pytest_last_session      = ""
    2              0.000003 let g:pytest_looponfail        = 0
                            
                            " Process ID of async calls in NeoVim
    2              0.000004 let s:id                       = 0
                            
                            
    2              0.000007 function! s:PytestSyntax() abort
                              let b:current_syntax = 'pytest'
                              syn match PytestPlatform              '\v^(platform(.*))'
                              syn match PytestTitleDecoration       "\v\={2,}"
                              syn match PytestTitle                 "\v\s+(test session starts)\s+"
                              syn match PytestCollecting            "\v(collecting\s+(.*))"
                              syn match PytestPythonFile            "\v((.*.py\s+))"
                              syn match PytestFooterFail            "\v\s+((.*)(failed|error) in(.*))\s+"
                              syn match PytestFooter                "\v\s+((.*)passed in(.*))\s+"
                              syn match PytestFailures              "\v\s+(FAILURES|ERRORS)\s+"
                              syn match PytestErrors                "\v^E\s+(.*)"
                              syn match PytestDelimiter             "\v_{3,}"
                              syn match PytestFailedTest            "\v_{3,}\s+(.*)\s+_{3,}"
                            
                              hi def link PytestPythonFile          String
                              hi def link PytestPlatform            String
                              hi def link PytestCollecting          String
                              hi def link PytestTitleDecoration     Comment
                              hi def link PytestTitle               String
                              hi def link PytestFooterFail          String
                              hi def link PytestFooter              String
                              hi def link PytestFailures            Number
                              hi def link PytestErrors              Number
                              hi def link PytestDelimiter           Comment
                              hi def link PytestFailedTest          Comment
                            endfunction
                            
                            
    2              0.000004 function! s:PytestFailsSyntax() abort
                              let b:current_syntax = 'pytestFails'
                              syn match PytestQDelimiter            "\v\s+(\=\=\>\>)\s+"
                              syn match PytestQLine                 "Line:"
                              syn match PytestQPath                 "\v\s+(Path:)\s+"
                              syn match PytestQEnds                 "\v\s+(Ends On:)\s+"
                            
                              hi def link PytestQDelimiter          Comment
                              hi def link PytestQLine               String
                              hi def link PytestQPath               String
                              hi def link PytestQEnds               String
                            endfunction
                            
                            
    2              0.000004 function! s:LoopOnFail(type)
                            
                                augroup pytest_loop_autocmd
                                    au!
                                    if g:pytest_looponfail == 0
                                        return
                                    elseif a:type == 'method'
                                        autocmd! BufWritePost *.py call s:LoopProxy('method')
                                    elseif a:type == 'class'
                                        autocmd! BufWritePost *.py call s:LoopProxy('class')
                                    elseif a:type == 'function'
                                        autocmd! BufWritePost *.py call s:LoopProxy('function')
                                    elseif a:type == 'file'
                                        autocmd! BufWritePost *.py call s:LoopProxy('file')
                                    endif
                                augroup END
                            
                            endfunction
                            
                            
    2              0.000003 function! s:LoopProxy(type)
                                " Very repetitive function, but allows specific function
                                " calling when autocmd is executed
                                if g:pytest_looponfail == 1
                                    if a:type == 'method'
                                        call s:ThisMethod(0, 'False')
                                    elseif a:type == 'class'
                                        call s:ThisClass(0, 'False')
                                    elseif a:type == 'function'
                                        call s:ThisFunction(0, 'False')
                                    elseif a:type == 'file'
                                        call s:ThisFile(0, 'False')
                                    endif
                            
                                    " FIXME Removing this for now until I can find
                                    " a way of getting the bottom only on fails
                                    " Go to the very bottom window
                                    "call feedkeys("\<C-w>b", 'n')
                                else
                                    au! pytest_loop_autocmd
                                endif
                            endfunction
                            
                            
                            " Close the Pytest buffer if it is the last one open
    2              0.000004 function! s:CloseIfLastWindow()
                              if winnr("$") == 1
                                q
                              endif
                            endfunction
                            
                            
    2              0.000004 function! s:GoToInlineError(direction)
                                let orig_line = line('.')
                                let last_line = line('$')
                            
                                " Move to the line we need
                                let move_to = orig_line + a:direction
                            
                                if move_to > last_line
                                    let move_to = 1
                                    exe move_to
                                elseif move_to <= 1
                                    let move_to = last_line
                                    exe move_to
                                else
                                    exe move_to
                                endif
                            
                                if move_to == 1
                                    let _num = move_to
                                else
                                    let _num = move_to - 1
                                endif
                            
                                "  Goes to the current open window that matches
                                "  the error path and moves you there. Pretty awesome
                                if (len(g:pytest_session_errors) > 0)
                                    let select_error = g:pytest_session_errors[_num]
                                    let line_number  = select_error['file_line']
                                    let error_path   = select_error['file_path']
                                    let exception    = select_error['exception']
                                    let error        = select_error['error']
                            
                                    " Go to previous window
                                    exe 'wincmd p'
                                    let file_name    = expand("%:t")
                                    if error_path =~ file_name
                                        execute line_number
                                        execute 'normal! zz'
                                        exe 'wincmd p'
                                        let orig_line = _num+1
                                        exe orig_line
                                        let message = "Failed test: " . _num . "\t ==>> " . exception . " ". error
                                        call s:Echo(message, 1)
                                        return
                                    else " we might have an error on another file
                                        let message = "Failed test on different buffer. Skipping..."
                                        call s:Echo(message, 1)
                                        exe 'wincmd p'
                                    endif
                            
                                else
                                    call s:Echo("Failed test list is empty")
                                endif
                            endfunction
                            
    2              0.000005 function! s:GoToError(direction)
                                "   0 goes to first
                                "   1 goes forward
                                "  -1 goes backwards
                                "   2 goes to last
                                "   3 goes to the end of current error
                                call s:ClearAll()
                                let going = "First"
                                if (len(g:pytest_session_errors) > 0)
                                    if (a:direction == -1)
                                        let going = "Previous"
                                        if (g:pytest_session_error == 0 || g:pytest_session_error == 1)
                                            let g:pytest_session_error = 1
                                        else
                                            let g:pytest_session_error = g:pytest_session_error - 1
                                        endif
                                    elseif (a:direction == 1)
                                        let going = "Next"
                                        if (g:pytest_session_error != len(g:pytest_session_errors))
                                            let g:pytest_session_error = g:pytest_session_error + 1
                                        endif
                                    elseif (a:direction == 0)
                                        let g:pytest_session_error = 1
                                    elseif (a:direction == 2)
                                        let going = "Last"
                                        let g:pytest_session_error = len(g:pytest_session_errors)
                                    elseif (a:direction == 3)
                                        if (g:pytest_session_error == 0 || g:pytest_session_error == 1)
                                            let g:pytest_session_error = 1
                                        endif
                                        let select_error = g:pytest_session_errors[g:pytest_session_error]
                                        let line_number = select_error['file_line']
                                        let error_path = select_error['file_path']
                                        let exception = select_error['exception']
                                        let file_name = expand("%:t")
                                        if error_path =~ file_name
                                            execute line_number
                                        else
                                            call s:OpenError(error_path)
                                            execute line_number
                                        endif
                                        let message = "End of Failed test: " . g:pytest_session_error . "\t ==>> " . exception
                                        call s:Echo(message, 1)
                                        return
                                    endif
                            
                                    if (a:direction != 3)
                                        let select_error = g:pytest_session_errors[g:pytest_session_error]
                                        let line_number = select_error['line']
                                        let error_path = select_error['path']
                                        let exception = select_error['exception']
                                        let error = select_error['error']
                                        let file_name = expand("%:t")
                                        if error_path =~ file_name
                                            execute line_number
                                        else
                                            call s:OpenError(error_path)
                                            execute line_number
                                        endif
                                        let message = going . " Failed test: " . g:pytest_session_error . "\t ==>> " . exception . " " . error
                                        call s:Echo(message, 1)
                                        return
                                    endif
                                else
                                    call s:Echo("Failed test list is empty")
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:Echo(msg, ...)
                                redraw!
                                let x=&ruler | let y=&showcmd
                                set noruler noshowcmd
                                if (a:0 == 1)
                                    echo a:msg
                                else
                                    echohl WarningMsg | echo a:msg | echohl None
                                endif
                            
                                let &ruler=x | let &showcmd=y
                            endfun
                            
                            
                            " Always goes back to the first instance
                            " and returns that if found
    2              0.000004 function! s:FindPythonObject(obj)
                                let orig_line   = line('.')
                                let orig_col    = col('.')
                                let orig_indent = indent(orig_line)
                            
                            
                                if (a:obj == "class")
                                    let objregexp  = '\v^\s*(.*class)\s+(\w+)\s*'
                                    let max_indent_allowed = 0
                                elseif (a:obj == "method")
                                    let objregexp = '\v^\s*(.*def)\s+(\w+)\s*\(\s*(self[^)]*)'
                                    let max_indent_allowed = 4
                                else
                                    let objregexp = '\v^\s*(.*def)\s+(\w+)\s*\(\s*(.*self)@!'
                                    let max_indent_allowed = orig_indent
                                endif
                            
                                let flag = "Wb"
                            
                                while search(objregexp, flag) > 0
                                    "
                                    " Very naive, but if the indent is less than or equal to four
                                    " keep on going because we assume you are nesting.
                                    " Do not count lines that are comments though.
                                    "
                                    if (indent(line('.')) <= 4) && !(getline(line('.')) =~ '\v^\s*#(.*)')
                                      if (indent(line('.')) <= max_indent_allowed)
                                        return 1
                                      endif
                                    endif
                                endwhile
                            
                            endfunction
                            
                            
    2              0.000004 function! s:NameOfCurrentClass()
                                let save_cursor = getpos(".")
                                normal! $<cr>
                                let find_object = s:FindPythonObject('class')
                                if (find_object)
                                    let line = getline('.')
                                    call setpos('.', save_cursor)
                                    let match_result = matchlist(line, ' *class \+\(\w\+\)')
                                    return match_result[1]
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:NameOfCurrentMethod()
                                normal! $<cr>
                                let find_object = s:FindPythonObject('method')
                                if (find_object)
                                    let line = getline('.')
                                    let match_result = matchlist(line, ' *def \+\(\w\+\)')
                                    return match_result[1]
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:NameOfCurrentFunction()
                                normal! $<cr>
                                let find_object = s:FindPythonObject('function')
                                if (find_object)
                                    let line = getline('.')
                                    let match_result = matchlist(line, ' *def \+\(\w\+\)')
                                    return match_result[1]
                                endif
                            endfunction
                            
                            
    2              0.000002 function! s:CurrentPath()
                                let cwd = '"' . expand("%:p") . '"'
                                return cwd
                            endfunction
                            
    2              0.000002 function! s:ProjectPath()
                                let projecttestdir = finddir('tests','.;')
                                let projecttestfile = findfile('tests.py','.;')
                            
                                if (len(projecttestdir) == 0)
                                    let projecttestdir = finddir('test', '.;')
                                endif
                            
                                if(len(projecttestdir) != 0)
                                    let path = fnamemodify(projecttestdir, ':p:h')
                                elseif(len(projecttestfile) != 0)
                                    let path = fnamemodify(projecttestfile, ':p')
                                else
                                    let path = ''
                                endif
                            
                                return path
                            endfunction
                            
                            
    2              0.000002 function! s:RunInSplitWindow(path)
                                let cmd = "py.test --tb=short " . a:path
                                let command = join(map(split(cmd), 'expand(v:val)'))
                                let winnr = bufwinnr('PytestVerbose.pytest')
                                silent! execute  winnr < 0 ? 'botright new ' . 'PytestVerbose.pytest' : winnr . 'wincmd w'
                                setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number filetype=pytest
                                silent! execute 'silent %!'. command
                                silent! execute 'resize ' . line('$')
                                silent! execute 'nnoremap <silent> <buffer> q :q! <CR>'
                                call s:PytestSyntax()
                                autocmd! BufEnter LastSession.pytest call s:CloseIfLastWindow()
                            endfunction
                            
                            
    2              0.000004 function! s:OpenError(path)
                            	let winnr = bufwinnr('GoToError.pytest')
                            	silent! execute  winnr < 0 ? 'botright new ' . ' GoToError.pytest' : winnr . 'wincmd w'
                            	setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number
                                silent! execute ":e " . a:path
                                silent! execute 'nnoremap <silent> <buffer> q :q! <CR>'
                                autocmd! BufEnter LastSession.pytest call s:CloseIfLastWindow()
                            endfunction
                            
                            
    2              0.000002 function! s:ShowError()
                                call s:ClearAll()
                                if (len(g:pytest_session_errors) == 0)
                                    call s:Echo("No Failed test error from a previous run")
                                    return
                                endif
                                if (g:pytest_session_error == 0)
                                    let error_n = 1
                                else
                                    let error_n = g:pytest_session_error
                                endif
                                let error_dict = g:pytest_session_errors[error_n]
                                if (error_dict['error'] == "")
                                    call s:Echo("No failed test error saved from last run.")
                                    return
                                endif
                            
                            	let winnr = bufwinnr('ShowError.pytest')
                            	silent! execute  winnr < 0 ? 'botright new ' . ' ShowError.pytest' : winnr . 'wincmd w'
                            	setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile number nowrap
                                autocmd! BufEnter LastSession.pytest call s:CloseIfLastWindow()
                                silent! execute 'nnoremap <silent> <buffer> q :q! <CR>'
                                let line_number = error_dict['file_line']
                                let error = error_dict['error']
                                let message = "Test Error: " . error
                                call append(0, error)
                                exe '0'
                                exe '0|'
                                silent! execute 'resize ' . line('$')
                                exe 'wincmd p'
                            endfunction
                            
                            
    2              0.000003 function! s:ShowFails(...)
                                call s:ClearAll()
                                au BufLeave *.pytest echo "" | redraw
                                if a:0 > 0
                                    let gain_focus = a:0
                                else
                                    let gain_focus = 0
                                endif
                                if (len(g:pytest_session_errors) == 0)
                                    call s:Echo("No failed tests from a previous run")
                                    return
                                endif
                            	let winnr = bufwinnr('Fails.pytest')
                            	silent! execute  winnr < 0 ? 'botright new ' . 'Fails.pytest' : winnr . 'wincmd w'
                            	setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number filetype=pytest
                                let blank_line = repeat(" ",&columns - 1)
                                exe "normal! i" . blank_line
                                hi RedBar ctermfg=white ctermbg=red guibg=red
                                match RedBar /\%1l/
                                for err in keys(g:pytest_session_errors)
                                    let err_dict    = g:pytest_session_errors[err]
                                    let line_number = err_dict['line']
                                    let exception   = err_dict['exception']
                                    let path_error  = err_dict['path']
                                    let ends        = err_dict['file_path']
                                    let error       = err_dict['error']
                                    if (path_error == ends)
                                        let message = printf('Line: %-*u ==>> %-*s %s ==>> %s', 6, line_number, 14, exception, error, path_error)
                                    else
                                        let message = printf('Line: %-*u ==>> %-*s %s ==>> %s', 6, line_number, 24, exception, error, ends)
                                    endif
                                    let error_number = err + 1
                                    call setline(error_number, message)
                                endfor
                            
                            	silent! execute 'resize ' . line('$')
                                autocmd! BufEnter LastSession.pytest call s:CloseIfLastWindow()
                                nnoremap <silent> <buffer> q       :call <sid>ClearAll(1)<CR>
                                nnoremap <silent> <buffer> <Enter> :call <sid>ClearAll(1)<CR>
                                nnoremap <script> <buffer> <C-n>   :call <sid>GoToInlineError(1)<CR>
                                nnoremap <script> <buffer> <down>  :call <sid>GoToInlineError(1)<CR>
                                nnoremap <script> <buffer> j       :call <sid>GoToInlineError(1)<CR>
                                nnoremap <script> <buffer> <C-p>   :call <sid>GoToInlineError(-1)<CR>
                                nnoremap <script> <buffer> <up>    :call <sid>GoToInlineError(-1)<CR>
                                nnoremap <script> <buffer> k       :call <sid>GoToInlineError(-1)<CR>
                                call s:PytestFailsSyntax()
                                exe "normal! 0|h"
                                if (! gain_focus)
                                    exe 'wincmd p'
                                else
                                    call s:Echo("Hit Return or q to exit", 1)
                                endif
                            endfunction
                            
                            
    2              0.000002 function! s:LastSession()
                                call s:ClearAll()
                                if (len(g:pytest_last_session) == 0)
                                    call s:Echo("There is currently no saved last session to display")
                                    return
                                endif
                            	let winnr = bufwinnr('LastSession.pytest')
                            	silent! execute  winnr < 0 ? 'botright new ' . 'LastSession.pytest' : winnr . 'wincmd w'
                            	setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number filetype=pytest
                                let session = split(g:pytest_last_session, '\n')
                                call append(0, session)
                            	silent! execute 'resize ' . line('$')
                                silent! execute 'normal! gg'
                                autocmd! BufEnter LastSession.pytest call s:CloseIfLastWindow()
                                nnoremap <silent> <buffer> q       :call <sid>ClearAll(1)<CR>
                                nnoremap <silent> <buffer> <Enter> :call <sid>ClearAll(1)<CR>
                                call s:PytestSyntax()
                                exe 'wincmd p'
                            endfunction
                            
                            
    2              0.000003 function! s:ToggleFailWindow()
                            	let winnr = bufwinnr('Fails.pytest')
                                if (winnr == -1)
                                    call s:ShowFails()
                                else
                                    silent! execute winnr . 'wincmd w'
                                    silent! execute 'q'
                                    silent! execute 'wincmd p'
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:ToggleLastSession()
                            	let winnr = bufwinnr('LastSession.pytest')
                                if (winnr == -1)
                                    call s:LastSession()
                                else
                                    silent! execute winnr . 'wincmd w'
                                    silent! execute 'q'
                                    silent! execute 'wincmd p'
                                endif
                            endfunction
                            
                            
    2              0.000002 function! s:ToggleShowError()
                            	let winnr = bufwinnr('ShowError.pytest')
                                if (winnr == -1)
                                    call s:ShowError()
                                else
                                    silent! execute winnr . 'wincmd w'
                                    silent! execute 'q'
                                    silent! execute 'wincmd p'
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:ClearAll(...)
                                let current = winnr()
                                let bufferL = [ 'Fails.pytest', 'LastSession.pytest', 'ShowError.pytest', 'PytestVerbose.pytest' ]
                                for b in bufferL
                                    let _window = bufwinnr(b)
                                    if (_window != -1)
                                        silent! execute _window . 'wincmd w'
                                        silent! execute 'q'
                                    endif
                                endfor
                            
                                " Remove any echoed messages
                                if (a:0 == 1)
                                    " Try going back to our starting window
                                    " and remove any left messages
                                    call s:Echo('')
                                    silent! execute 'wincmd p'
                                else
                                    execute current . 'wincmd w'
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:ResetAll()
                                " Resets all global vars
                                let g:pytest_session_errors    = {}
                                let g:pytest_session_error     = 0
                                let g:pytest_last_session      = ""
                                let g:pytest_looponfail        = 0
                            endfunction!
                            
                            
    2              0.000004 function! s:RunPyTest(path, ...)
                                if (a:0 > 0)
                                  let parametrized = a:1
                                else
                                  let parametrized = 0
                                endif
                            
                                let g:pytest_last_session = ""
                            
                                if (len(parametrized) && parametrized != "0")
                                    let cmd = "py.test -k " . parametrized . " --tb=short " . a:path
                                else
                                    let cmd = "py.test --tb=short " . '"' . a:path . '"'
                                endif
                            
                                " NeoVim support
                                if has('nvim')
                                  if s:id
                                    silent! call jobstop(s:id)
                                  endif
                            
                                  let tempfile = fnameescape(tempname())
                            
                                  " If the directory for the temp files does not exist go
                                  " ahead and create one for us
                                  let temp_dir_location = fnamemodify(tempname(),":p:h:")
                                  if !exists(temp_dir_location)
                                    call system('mkdir ' . temp_dir_location)
                                  endif
                            
                                  let s:cmdline =  cmd . " > " . tempfile
                            
                                  let s:id = jobstart(s:cmdline, {
                                        \ 'tempfile':  tempfile,
                                        \ 'on_exit':   's:HandleOutput' })
                                  return
                                endif
                            
                                let out = system(cmd)
                                call s:HandleOutput(out)
                            endfunction
                            
                            
    2              0.000003 function! s:HandleOutput(...)
                                if a:0 > 0
                                    let stdout = a:1
                                else
                                    let stdout = join(readfile(self.tempfile), "\n")
                                    call delete(self.tempfile)
                                endif
                            
                                " if py.test insists in giving us color, sanitize the output
                                " note that ^[ is really:
                                " Ctrl-V Ctrl-[
                                let out = substitute(stdout, '[\d\+m', '', 'g')
                            
                                " Pointers and default variables
                                let g:pytest_session_errors = {}
                                let g:pytest_session_error  = 0
                                let g:pytest_last_session   = stdout
                            
                                for w in split(stdout, '\n')
                                    if w =~ '\v\=\=\s+\d+ passed in'
                                        call s:ParseSuccess(out)
                                        return
                                    elseif w =~ '\v\s+(FAILURES)\s+'
                                        call s:ParseFailures(out)
                                        return
                                    elseif w =~ '\v\s+(ERRORS)\s+'
                                        call s:ParseErrors(out)
                                        return
                                    elseif w =~ '\v^(.*)\s*ERROR:\s+'
                                        call s:RedBar()
                                        echo "py.test had an Error, see :Pytest session for more information"
                                        if exists('$VIRTUAL_ENV')
                                          if !executable($VIRTUAL_ENV . "/bin/py.test")
                                            echo repeat("*", 80)
                                            echo " Detected an activated virtualenv but py.test was not found"
                                            echo " Make sure py.test is installed in the current virtualenv"
                                            echo " and present at:"
                                            echo " "
                                            echo "    " . $VIRTUAL_ENV . "/bin/py.test"
                                            echo " "
                                          endif
                                        endif
                                        return
                                    elseif w =~ '\v^(.*)\s*INTERNALERROR'
                                        call s:RedBar()
                                        echo "py.test had an InternalError, see :Pytest session for more information"
                                        return
                                    endif
                                endfor
                                call s:ParseSuccess(out)
                            
                                " If looponfail is set we no longer need it
                                " So clear the autocomand and set the global var to 0
                                let g:pytest_looponfail = 0
                                call s:LoopOnFail(0)
                            endfunction
                            
                            
    2              0.000003 function! s:ParseFailures(stdout)
                                " Pointers and default variables
                                let failed = 0
                                let errors = {}
                                let error = {}
                                let error_number = 0
                                let pytest_error = ""
                                let current_file = expand("%:t")
                                let file_regex =  '\v(^' . current_file . '|/' . current_file . ')'
                                let error['line'] = ""
                                let error['path'] = ""
                                let error['exception'] = ""
                            
                                " Loop through the output and build the error dict
                                for w in split(a:stdout, '\n')
                                    if w =~ '\v\s+(FAILURES)\s+'
                                        let failed = 1
                                    elseif w =~ '\v^(.*)\.py:(\d+):'
                                        if w =~ file_regex
                                            let match_result = matchlist(w, '\v:(\d+):')
                                            let error.line = match_result[1]
                                            let file_path = matchlist(w, '\v(.*.py):')
                                            let error.path = file_path[1]
                                        elseif w !~ file_regex
                                            " Because we have missed out on actual line and path
                                            " add them here to both file_line and line and file_path and
                                            " path so that reporting works
                                            let match_result = matchlist(w, '\v:(\d+):')
                                            let error.file_line = match_result[1]
                                            let error.line = match_result[1]
                                            let file_path = matchlist(w, '\v(.*.py):')
                                            let error.file_path = file_path[1]
                                            let error.path = file_path[1]
                                        endif
                                    elseif w =~  '\v^E\s+\w+(.*)\s*'
                                        let split_error = split(w, "E ")
                                        let actual_error = substitute(split_error[0],'\v^\s+|\s+$',"","g")
                                        let match_error = matchlist(actual_error, '\v(\w+):\s+(.*)')
                                        if (len(match_error))
                                            let error.exception = match_error[1]
                                            let error.error = match_error[2]
                                        elseif (len(split(actual_error, ' ')) == 1)
                                            " this means that we just got an exception with
                                            " no error message
                                            let error.exception = actual_error
                                            let error.error = ""
                                        else
                                            let error.exception = "AssertionError"
                                            let error.error = actual_error
                                        endif
                                    elseif w =~ '\v^(.*)\s*ERROR:\s+'
                                        let pytest_error = w
                                    endif
                            
                                    " At the end of the loop make sure we append the failure parsed to the
                                    " errors dictionary
                                    if ((error.line != "") && (error.path != "") && (error.exception != ""))
                                        try
                                            let end_file_path = error['file_path']
                                        catch /^Vim\%((\a\+)\)\=:E/
                                            let error.file_path = error.path
                                            let error.file_line = error.line
                                        endtry
                                        let error_number = error_number + 1
                                        let errors[error_number] = error
                                        let error = {}
                                        let error['line'] = ""
                                        let error['path'] = ""
                                        let error['exception'] = ""
                                    endif
                                endfor
                            
                                " Display the result Bars
                                if (failed == 1)
                                    let g:pytest_session_errors = errors
                                    call s:ShowFails(1)
                                elseif (failed == 0 && pytest_error == "")
                                    call s:GreenBar()
                                elseif (pytest_error != "")
                                    call s:RedBar()
                                    echo "py.test " . pytest_error
                                endif
                            endfunction
                            
                            
    2              0.000006 function! s:ParseErrors(stdout)
                                " Pointers and default variables
                                let failed = 0
                                let errors = {}
                                let error = {}
                                " Loop through the output and build the error dict
                            
                                for w in split(a:stdout, '\n')
                                   if w =~ '\v\s+ERROR\s+collecting'
                                        call s:RedBar()
                                        echo "py.test had an error collecting tests, see :Pytest session for more information"
                                        return
                            
                                    elseif w =~ '\v\s+(ERRORS)\s+'
                                        let failed = 1
                                    elseif w =~ '\v^E\s+(File)'
                                        let match_line_no = matchlist(w, '\v\s+(line)\s+(\d+)')
                                        let error['line'] = match_line_no[2]
                                        let error['file_line'] = match_line_no[2]
                                        let split_file = split(w, "E ")
                                        let match_file = matchlist(split_file[0], '\v"(.*.py)"')
                                        let error['file_path'] = match_file[1]
                                        let error['path'] = match_file[1]
                                    elseif w =~ '\v^(.*)\.py:(\d+)'
                                        let match_result = matchlist(w, '\v:(\d+)')
                                        let error.line = match_result[1]
                                        let file_path = matchlist(w, '\v(.*.py):')
                                        let error.path = file_path[1]
                                    endif
                                    if w =~ '\v^E\s+(\w+):\s+'
                                        let split_error = split(w, "E ")
                                        let match_error = matchlist(split_error[0], '\v(\w+):')
                                        let error['exception'] = match_error[1]
                                        let flat_error = substitute(split_error[0],"^\\s\\+\\|\\s\\+$","","g")
                                        let error.error = flat_error
                                    endif
                                endfor
                                try
                                    let end_file_path = error['file_path']
                                catch /^Vim\%((\a\+)\)\=:E/
                                    let error.file_path = error.path
                                    let error.file_line = error.line
                                endtry
                            
                                " FIXME
                                " Now try to really make sure we have some stuff to pass
                                " who knows if we are getting more of these :/ quick fix for now
                                let error['exception'] = get(error, 'exception', 'AssertionError')
                                let error['error']     = get(error, 'error', 'py.test had an error, please see :Pytest session for more information')
                                let errors[1] = error
                            
                                " Display the result Bars
                                if (failed == 1)
                                    let g:pytest_session_errors = errors
                                    call s:ShowFails(1)
                                elseif (failed == 0)
                                    call s:GreenBar()
                                endif
                            endfunction
                            
                            
    2              0.000005 function! s:ParseSuccess(stdout) abort
                                let passed = 0
                                " A passing test (or tests would look like:
                                " ========================== 17 passed in 0.43 seconds ===========================
                                " this would insert that into the resulting GreenBar but only the
                                " interesting portion
                                for w in split(a:stdout, '\n')
                                    if w =~ '\v^\={14,}\s+\d+\s+passed'
                                        let passed = matchlist(w, '\v\d+\s+passed(.*)\s+')[0]
                                    elseif w =~ '\v^\={14,}\s+\d+\s+skipped'
                                        let passed = matchlist(w, '\v\d+\s+skipped(.*)\s+')[0]
                                    endif
                                endfor
                                " fix this obvious redundancy
                                if passed
                                    redraw
                                    let length = strlen(passed) + 1
                                    " The GUI looks too bright with plain green as a background
                                    " so make sure we use a solarized-like green and set the foreground
                                    " to black
                                    hi GreenBar ctermfg=black ctermbg=green guibg=#719e07 guifg=black
                                    echohl GreenBar
                                    echon passed . repeat(" ",&columns - length)
                                    echohl
                                else
                                    " At this point we have parsed the output and have not been able to
                                    " determine if the test run has had pytest errors, or faillures,
                                    " passing tests, or even skipped ones. So something must be weird with
                                    " the output. Instead of defaulting to 'All tests passed!' warn the
                                    " user that we were unable to parse the output.
                                    redraw
                                    let message = "Unable to parse output. If using a plugin that alters the default output, consider disabling it. See :Pytest session"
                                    let length = strlen(message) + 1
                                    hi YellowBar ctermfg=black ctermbg=yellow guibg=#e5e500 guifg=black
                                    echohl YellowBar
                                    echon message . repeat(" ",&columns - length)
                                    echohl
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:RedBar()
                                redraw
                                hi RedBar ctermfg=white ctermbg=red guibg=red
                                echohl RedBar
                                echon repeat(" ",&columns - 1)
                                echohl
                            endfunction
                            
                            
    2              0.000002 function! s:GreenBar()
                                redraw
                                hi GreenBar ctermfg=black ctermbg=green guibg=green
                                echohl GreenBar
                                echon "All tests passed." . repeat(" ",&columns - 18)
                                echohl
                            endfunction
                            
                            
    2              0.000003 function! s:ThisMethod(verbose, ...)
                                let save_cursor = getpos('.')
                                call s:ClearAll()
                                let m_name  = s:NameOfCurrentMethod()
                                let is_parametrized = s:HasPythonDecorator(line('.'))
                            
                                let c_name  = s:NameOfCurrentClass()
                                let abspath = s:CurrentPath()
                                if (strlen(m_name) == 1)
                                    call setpos('.', save_cursor)
                                    call s:Echo("Unable to find a matching method for testing")
                                    return
                                elseif (strlen(c_name) == 1)
                                    call setpos('.', save_cursor)
                                    call s:Echo("Unable to find a matching class for testing")
                                    return
                                endif
                            
                                " If we didn't error, still, save the cursor so we are back
                                " to the original position
                                call setpos('.', save_cursor)
                            
                                if is_parametrized
                                    let path =  abspath . "::" . c_name
                                    let parametrized_flag = m_name
                                    let message = "py.test ==> Running test for parametrized method " . m_name
                                else
                                    let path =  abspath . "::" . c_name . "::" . m_name
                                    let parametrized_flag = "0"
                                    let message = "py.test ==> Running test for method " . m_name
                                endif
                            
                                call s:Echo(message, 1)
                                if len(a:2)
                                  call s:Delgado(path, a:2, message)
                                  return
                                endif
                                if ((a:1 == '--pdb') || (a:1 == '-s'))
                                    call s:Pdb(path, a:1)
                                    return
                                endif
                                if (a:verbose == 1)
                                    call s:RunInSplitWindow(path)
                                else
                                   call s:RunPyTest(path, parametrized_flag)
                                endif
                            endfunction
                            
                            
    2              0.000005 function! s:HasPythonDecorator(line)
                                " Get to the previous line where the decorator lives
                                let line = a:line -1
                                " if it is whitespace or there is nothing there, return
                                if (getline(line) =~ '^\\s*\\S')
                                    return 0
                                endif
                            
                                " now keep searching back as long as there aren't any other
                                " empty lines
                                while (getline(line) !~ '^\\s*\\S')
                                    if (getline(line) =~ '\v^(.*\@[a-zA-Z])')
                                        return 1
                                    elseif (getline(line) =~ '\v^\s*(.*def)\s+(\w+)\s*\(\s*')
                                        " so we found either a function or a class, therefore, no way we have
                                        " a decorator
                                        return 0
                                    elseif (line < 1)
                                        " we went all the way to the top of the file, no need to keep going
                                        return 0
                                    endif
                                    let line = line - 1
                                endwhile
                            
                            endfunction
                            
                            
    2              0.000004 function! s:ThisFunction(verbose, ...)
                                let save_cursor = getpos('.')
                                call s:ClearAll()
                                let c_name      = s:NameOfCurrentFunction()
                                let is_parametrized = s:HasPythonDecorator(line('.'))
                                let abspath     = s:CurrentPath()
                                if (strlen(c_name) == 1)
                                    call setpos('.', save_cursor)
                                    call s:Echo("Unable to find a matching function for testing")
                                    return
                                endif
                                let message  = "py.test ==> Running tests for function " . c_name
                                call s:Echo(message, 1)
                            
                                if is_parametrized
                                    let path = abspath
                                else
                                    let path = abspath . "::" . c_name
                                endif
                            
                                if len(a:2)
                                  call s:Delgado(path, a:2, message)
                                  return
                                endif
                            
                                if ((a:1 == '--pdb') || (a:1 == '-s'))
                                    call s:Pdb(path, a:1)
                                    return
                                endif
                            
                                if (a:verbose == 1)
                                    call s:RunInSplitWindow(path)
                                else
                                    call s:RunPyTest(path, c_name)
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:ThisClass(verbose, ...)
                                let save_cursor = getpos('.')
                                call s:ClearAll()
                                let c_name      = s:NameOfCurrentClass()
                                let abspath     = s:CurrentPath()
                                if (strlen(c_name) == 1)
                                    call setpos('.', save_cursor)
                                    call s:Echo("Unable to find a matching class for testing")
                                    return
                                endif
                                let message  = "py.test ==> Running tests for class " . c_name
                                call s:Echo(message, 1)
                            
                                let path = abspath . "::" . c_name
                                if len(a:2)
                                  call s:Delgado(path, a:2, message)
                                  return
                                endif
                            
                                if ((a:1 == '--pdb') || (a:1 == '-s'))
                                    call s:Pdb(path, a:1)
                                    return
                                endif
                            
                                if (a:verbose == 1)
                                    call s:RunInSplitWindow(path)
                                else
                                    call s:RunPyTest(path)
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:ThisFile(verbose, ...)
                                call s:ClearAll()
                                let message = "py.test ==> Running tests for entire file"
                                call s:Echo(message, 1)
                                let abspath = s:CurrentPath()
                                if len(a:2)
                                  call s:Delgado(abspath, a:2, message)
                                  return
                                endif
                            
                                if ((a:1 == '--pdb') || (a:1 == '-s'))
                                    call s:Pdb(abspath, a:1)
                                    return
                                endif
                            
                                if (a:verbose == 1)
                                    call s:RunInSplitWindow(abspath)
                                else
                                    call s:RunPyTest(abspath)
                                endif
                            endfunction
                            
    2              0.000003 function! s:ThisProject(verbose, ...)
                                call s:ClearAll()
                                let message = "py.test ==> Running tests for entire project"
                                call s:Echo(message, 1)
                                let abspath = s:ProjectPath()
                            
                                if len(abspath) <= 0
                                    call s:RedBar()
                                    echo "There are no tests defined for this project"
                                    return
                                endif
                            
                                if ((a:1 == '--pdb') || (a:1 == '-s'))
                                    call s:Pdb(abspath, a:1)
                                    return
                                endif
                            
                                if (a:verbose == 1)
                                    call s:RunInSplitWindow(abspath)
                                else
                                    call s:RunPyTest(abspath)
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:Pdb(path, ...)
                                let pdb_command = "py.test " . a:1 . " " . a:path
                                if has('nvim')
                                    exe ":terminal! " . pdb_command
                                else
                                    exe ":!" . pdb_command
                                endif
                            endfunction
                            
                            
    2              0.000004 function! s:Delgado(path, arguments, message)
                                let args = a:arguments[1:]
                                let str_args = ""
                                if len(args)
                                  for item in args
                                    let str_args = str_args . '\"' . item .'\",'
                                  endfor
                                endif
                                let args_as_list = '[' . str_args . '\"' . a:path . '\"]'
                                let json_arg = '{\"py.test\" :'. args_as_list . '}'
                                let command = ":!" . "echo \"" . json_arg . "\"| nc -U /tmp/pytest.sock" . " &"
                                " If debugging this, uncomment the next line
                                " so that it echoes to :messages
                                " echom command
                                silent! exe command
                                if !has("gui_running")
                                    call s:Echo(a:message, 1)
                                endif
                            endfunction
                            
                            
    2              0.000003 function! s:Version()
                                call s:Echo("pytest.vim version 1.1.5", 1)
                            endfunction
                            
                            
    2              0.000004 function! s:Completion(ArgLead, CmdLine, CursorPos)
                                let result_order = "first\nlast\nnext\nprevious\n"
                                let test_objects = "class\nmethod\nfunction\nfile\nproject\nprojecttestwd\n"
                                let optional     = "verbose\nlooponfail\nclear\n"
                                let reports      = "fails\nerror\nsession\nend\n"
                                let pyversion    = "version\n"
                                let pdb          = "--pdb\n-s\n"
                                return test_objects . result_order . reports . optional . pyversion . pdb
                            endfunction
                            
                            
    2              0.000003 function! s:Proxy(action, ...)
                                if (executable("py.test") == 0)
                                    call s:Echo("py.test not found. This plugin needs py.test installed and accessible")
                                    return
                                endif
                            
                                " Some defaults
                                let verbose = 0
                                let pdb     = 'False'
                                let looponfail = 0
                                let delgado = []
                            
                                if (a:0 > 0)
                                    if (a:1 == 'verbose')
                                        let verbose = 1
                                    elseif (a:1 == '--pdb')
                                        let pdb = '--pdb'
                                    elseif (a:1 == '-s')
                                        let pdb = '-s'
                                    elseif (a:1 == 'looponfail')
                                        let g:pytest_looponfail = 1
                                        let looponfail = 1
                                    elseif (a:1 == 'delgado')
                                        let delgado = a:000
                                    endif
                                endif
                                if (a:action == "class")
                                    if looponfail == 1
                                        call s:LoopOnFail(a:action)
                                        call s:ThisClass(verbose, pdb, delgado)
                                    else
                                        call s:ThisClass(verbose, pdb, delgado)
                                    endif
                                elseif (a:action == "method")
                                    if looponfail == 1
                                        call s:LoopOnFail(a:action)
                                        call s:ThisMethod(verbose, pdb, delgado)
                                    else
                                        call s:ThisMethod(verbose, pdb, delgado)
                                    endif
                                elseif (a:action == "function")
                                    if looponfail == 1
                                        call s:LoopOnFail(a:action)
                                        call s:ThisFunction(verbose, pdb, delgado)
                                    else
                                        call s:ThisFunction(verbose, pdb, delgado)
                                    endif
                                elseif (a:action == "file")
                                    if looponfail == 1
                                        call s:LoopOnFail(a:action)
                                        call s:ThisFile(verbose, pdb, delgado)
                                    else
                                        call s:ThisFile(verbose, pdb, delgado)
                                    endif
                                elseif (a:action == "project" )
                                    if looponfail ==1
                                        call s:LoopOnFail(a:action)
                                        call s:ThisProject(verbose, pdb, delgado)
                                    else
                                        call s:ThisProject(verbose, pdb,delgado)
                                    endif
                                elseif (a:action == "projecttestwd")
                                    let projecttests = s:ProjectPath()
                                    call s:Echo(projecttests)
                                elseif (a:action == "fails")
                                    call s:ToggleFailWindow()
                                elseif (a:action == "next")
                                    call s:GoToError(1)
                                elseif (a:action == "previous")
                                    call s:GoToError(-1)
                                elseif (a:action == "first")
                                    call s:GoToError(0)
                                elseif (a:action == "last")
                                    call s:GoToError(2)
                                elseif (a:action == "end")
                                    call s:GoToError(3)
                                elseif (a:action == "session")
                                    call s:ToggleLastSession()
                                elseif (a:action == "error")
                                    call s:ToggleShowError()
                                elseif (a:action == "clear")
                                    call s:ClearAll()
                                    call s:ResetAll()
                                elseif (a:action == "version")
                                    call s:Version()
                                else
                                    call s:Echo("Not a valid Pytest option ==> " . a:action)
                                endif
                            endfunction
                            
                            
    2              0.000030 command! -nargs=+ -complete=custom,s:Completion Pytest call s:Proxy(<f-args>)

SCRIPT  /usr/share/vim/vim80/ftplugin/python.vim
Sourced 2 times
Total time:   0.000361
 Self time:   0.000361

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	python
                            " Maintainer:	James Sully <sullyj3@gmail.com>
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Last Change:	Tue, 06 September 2016
                            " https://github.com/sullyj3/vim-ftplugin-python
                            
    2              0.000040 if exists("b:did_ftplugin") | finish | endif
    1              0.000004 let b:did_ftplugin = 1
    1              0.000007 let s:keepcpo= &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000006 setlocal cinkeys-=0#
    1              0.000007 setlocal indentkeys-=0#
    1              0.000002 setlocal include=^\\s*\\(from\\\|import\\)
    1              0.000003 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
    1              0.000002 setlocal suffixesadd=.py
    1              0.000002 setlocal comments=b:#,fb:-
    1              0.000003 setlocal commentstring=#\ %s
                            
    1              0.000002 setlocal omnifunc=pythoncomplete#Complete
                            
    1              0.000003 set wildignore+=*.pyc
                            
    1              0.000002 let b:next_toplevel='\v%$\|^(class\|def)>'
    1              0.000002 let b:prev_toplevel='\v^(class\|def)>'
    1              0.000002 let b:next='\v%$\|^\s*(class\|def)>'
    1              0.000002 let b:prev='\v^\s*(class\|def)>'
                            
    1              0.000037 execute "nnoremap <silent> <buffer> ]] :call <SID>Python_jump('n', '". b:next_toplevel."', 'W')<cr>"
    1              0.000013 execute "nnoremap <silent> <buffer> [[ :call <SID>Python_jump('n', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000013 execute "nnoremap <silent> <buffer> ]m :call <SID>Python_jump('n', '". b:next."', 'W')<cr>"
    1              0.000012 execute "nnoremap <silent> <buffer> [m :call <SID>Python_jump('n', '". b:prev."', 'Wb')<cr>"
                            
    1              0.000013 execute "onoremap <silent> <buffer> ]] :call <SID>Python_jump('o', '". b:next_toplevel."', 'W')<cr>"
    1              0.000012 execute "onoremap <silent> <buffer> [[ :call <SID>Python_jump('o', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000011 execute "onoremap <silent> <buffer> ]m :call <SID>Python_jump('o', '". b:next."', 'W')<cr>"
    1              0.000012 execute "onoremap <silent> <buffer> [m :call <SID>Python_jump('o', '". b:prev."', 'Wb')<cr>"
                            
    1              0.000012 execute "xnoremap <silent> <buffer> ]] :call <SID>Python_jump('x', '". b:next_toplevel."', 'W')<cr>"
    1              0.000012 execute "xnoremap <silent> <buffer> [[ :call <SID>Python_jump('x', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000011 execute "xnoremap <silent> <buffer> ]m :call <SID>Python_jump('x', '". b:next."', 'W')<cr>"
    1              0.000012 execute "xnoremap <silent> <buffer> [m :call <SID>Python_jump('x', '". b:prev."', 'Wb')<cr>"
                            
    1              0.000005 if !exists('*<SID>Python_jump')
                              fun! <SID>Python_jump(mode, motion, flags) range
                                  if a:mode == 'x'
                                      normal! gv
                                  endif
                            
                                  normal! 0
                            
                                  let cnt = v:count1
                                  mark '
                                  while cnt > 0
                                      call search(a:motion, a:flags)
                                      let cnt = cnt - 1
                                  endwhile
                            
                                  normal! ^
                              endfun
                            endif
                            
    1              0.000004 if has("browsefilter") && !exists("b:browsefilter")
    1              0.000005     let b:browsefilter = "Python Files (*.py)\t*.py\n" .
                                            \ "All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
    1              0.000004 if !exists("g:python_recommended_style") || g:python_recommended_style != 0
                                " As suggested by PEP8.
    1              0.000015     setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8
    1              0.000001 endif
                            
                            " First time: try finding "pydoc".
    1              0.000002 if !exists('g:pydoc_executable')
                                if executable('pydoc')
                                    let g:pydoc_executable = 1
                                else
                                    let g:pydoc_executable = 0
                                endif
                            endif
                            " If "pydoc" was found use it for keywordprg.
    1              0.000001 if g:pydoc_executable
    1              0.000005     setlocal keywordprg=pydoc
    1              0.000000 endif
                            
    1              0.000007 let &cpo = s:keepcpo
    1              0.000003 unlet s:keepcpo

SCRIPT  /home/cyrus/.vim/bundle/vim-python-pep8-indent/indent/python.vim
Sourced 2 times
Total time:   0.000565
 Self time:   0.000565

count  total (s)   self (s)
                            " PEP8 compatible Python indent file
                            " Language:         Python
                            " Maintainer:       Hynek Schlawack <hs@ox.cx>
                            " Prev Maintainer:  Eric Mc Sween <em@tomcom.de> (address invalid)
                            " Original Author:  David Bustos <bustos@caltech.edu> (address invalid)
                            " License:          CC0
                            "
                            " vim-python-pep8-indent - A nicer Python indentation style for vim.
                            " Written in 2004 by David Bustos <bustos@caltech.edu>
                            " Maintained from 2004-2005 by Eric Mc Sween <em@tomcom.de>
                            " Maintained from 2013 by Hynek Schlawack <hs@ox.cx>
                            "
                            " To the extent possible under law, the author(s) have dedicated all copyright
                            " and related and neighboring rights to this software to the public domain
                            " worldwide. This software is distributed without any warranty.
                            " You should have received a copy of the CC0 Public Domain Dedication along
                            " with this software. If not, see
                            " <http://creativecommons.org/publicdomain/zero/1.0/>.
                            
                            " Only load this indent file when no other was loaded.
    2              0.000008 if exists("b:did_indent")
                                finish
                            endif
    2              0.000006 let b:did_indent = 1
                            
    2              0.000012 setlocal expandtab
    2              0.000020 setlocal nolisp
    2              0.000006 setlocal autoindent
    2              0.000006 setlocal indentexpr=GetPythonPEPIndent(v:lnum)
    2              0.000006 setlocal indentkeys=!^F,o,O,<:>,0),0],0},=elif,=except
    2              0.000008 setlocal tabstop=4
    2              0.000004 setlocal softtabstop=4
    2              0.000004 setlocal shiftwidth=4
                            
    2              0.000002 let s:maxoff = 50
    2              0.000025 let s:block_rules = {
                                        \ '^\s*elif\>': ['if', 'elif'],
                                        \ '^\s*else\>': ['if', 'elif', 'for', 'try', 'except'],
                                        \ '^\s*except\>': ['try', 'except'],
                                        \ '^\s*finally\>': ['try', 'except', 'else']
                                        \ }
    2              0.000006 let s:paren_pairs = ['()', '{}', '[]']
    2              0.000005 let s:control_statement = '^\s*\(class\|def\|if\|while\|with\|for\|except\)\>'
    2              0.000004 let s:stop_statement = '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                            
                            " Skip strings and comments. Return 1 for chars to skip.
                            " jedi* refers to syntax definitions from jedi-vim for call signatures, which
                            " are inserted temporarily into the buffer.
    2              0.000006 let s:skip_special_chars = 'synIDattr(synID(line("."), col("."), 0), "name") ' .
                                        \ '=~? "\\vstring|comment|jedi\\S"'
                            
    2              0.000007 let s:skip_after_opening_paren = 'synIDattr(synID(line("."), col("."), 0), "name") ' .
                                        \ '=~? "\\vcomment|jedi\\S"'
                            
                            " Also ignore anything concealed.
                            " Wrapper around synconcealed for older Vim (7.3.429, used on Travis CI).
    2              0.000005 function! s:is_concealed(line, col)
                                let concealed = synconcealed(a:line, a:col)
                                return len(concealed) && concealed[0]
                            endfunction
    2              0.000006 if has('conceal')
    2              0.000007     let s:skip_special_chars .= '|| s:is_concealed(line("."), col("."))'
    2              0.000002 endif
                            
                            
    2              0.000007 let s:skip_search = 'synIDattr(synID(line("."), col("."), 0), "name") ' .
                                        \ '=~? "comment"'
                            
                            " Use 'shiftwidth()' instead of '&sw'.
                            " (Since Vim patch 7.3.629, 'shiftwidth' can be set to 0 to follow 'tabstop').
    2              0.000005 if exists('*shiftwidth')
    2              0.000005     function! s:sw()
                                    return shiftwidth()
                                endfunction
    2              0.000002 else
                                function! s:sw()
                                    return &sw
                                endfunction
                            endif
                            
    2              0.000004 function! s:pair_sort(x, y)
                                if a:x[0] == a:y[0]
                                    return a:x[1] == a:y[1] ? 0 : a:x[1] > a:y[1] ? 1 : -1
                                else
                                    return a:x[0] > a:y[0] ? 1 : -1
                                endif
                            endfunction
                            
                            " Find backwards the closest open parenthesis/bracket/brace.
    2              0.000004 function! s:find_opening_paren(...)
                                " optional arguments: line and column (defaults to 1) to search around
                                if a:0 > 0
                                    let view = winsaveview()
                                    call cursor(a:1, a:0 > 1 ? a:2 : 1)
                                    let ret = s:find_opening_paren()
                                    call winrestview(view)
                                    return ret
                                endif
                            
                                let stopline = max([0, line('.') - s:maxoff])
                            
                                " Return if cursor is in a comment.
                                exe 'if' s:skip_search '| return [0, 0] | endif'
                            
                                let positions = []
                                for p in s:paren_pairs
                                    call add(positions, searchpairpos(
                                       \ '\V'.p[0], '', '\V'.p[1], 'bnW', s:skip_special_chars, stopline))
                                endfor
                            
                                " Remove empty matches and return the type with the closest match
                                call filter(positions, 'v:val[0]')
                                call sort(positions, 's:pair_sort')
                            
                                return get(positions, -1, [0, 0])
                            endfunction
                            
                            " Find the start of a multi-line statement
    2              0.000005 function! s:find_start_of_multiline_statement(lnum)
                                let lnum = a:lnum
                                while lnum > 0
                                    if getline(lnum - 1) =~ '\\$'
                                        let lnum = prevnonblank(lnum - 1)
                                    else
                                        let [paren_lnum, _] = s:find_opening_paren(lnum)
                                        if paren_lnum < 1
                                            return lnum
                                        else
                                            let lnum = paren_lnum
                                        endif
                                    endif
                                endwhile
                            endfunction
                            
                            " Find the block starter that matches the current line
    2              0.000004 function! s:find_start_of_block(lnum, types)
                                let re = '\V\^\s\*\('.join(a:types, '\|').'\)\>'
                            
                                let lnum = a:lnum
                                let last_indent = indent(lnum) + 1
                                while lnum > 0 && last_indent > 0
                                    if indent(lnum) < last_indent
                                        if getline(lnum) =~# re
                                            return lnum
                                        endif
                                        let last_indent = indent(lnum)
                                    endif
                                    let lnum = prevnonblank(lnum - 1)
                                endwhile
                                return 0
                            endfunction
                            
                            " Is "expr" true for every position in "lnum", beginning at "start"?
                            " (optionally up to a:1 / 4th argument)
    2              0.000004 function! s:match_expr_on_line(expr, lnum, start, ...)
                                let text = getline(a:lnum)
                                let end = a:0 ? a:1 : len(text)
                                if a:start > end
                                    return 1
                                endif
                                let save_pos = getpos('.')
                                let r = 1
                                for i in range(a:start, end)
                                    call cursor(a:lnum, i)
                                    if !(eval(a:expr) || text[i-1] =~ '\s')
                                        let r = 0
                                        break
                                    endif
                                endfor
                                call setpos('.', save_pos)
                                return r
                            endfunction
                            
                            " Line up with open parenthesis/bracket/brace.
    2              0.000005 function! s:indent_like_opening_paren(lnum)
                                let [paren_lnum, paren_col] = s:find_opening_paren(a:lnum)
                                if paren_lnum <= 0
                                    return -2
                                endif
                                let text = getline(paren_lnum)
                                let base = indent(paren_lnum)
                            
                                let nothing_after_opening_paren = s:match_expr_on_line(
                                            \ s:skip_after_opening_paren, paren_lnum, paren_col+1)
                                let starts_with_closing_paren = getline(a:lnum) =~ '^\s*[])}]'
                            
                                if nothing_after_opening_paren
                                    if starts_with_closing_paren
                                        let res = base
                                    else
                                        let res = base + s:sw()
                                    endif
                                else
                                    " Indent to match position of opening paren.
                                    let res = paren_col
                                endif
                            
                                " If this line is the continuation of a control statement
                                " indent further to distinguish the continuation line
                                " from the next logical line.
                                if text =~# s:control_statement && res == base + s:sw()
                                    return base + s:sw() * 2
                                else
                                    return res
                                endif
                            endfunction
                            
                            " Match indent of first block of this type.
    2              0.000004 function! s:indent_like_block(lnum)
                                let text = getline(a:lnum)
                            
                                for [line_re, blocks] in items(s:block_rules)
                                    if text !~# line_re
                                        continue
                                    endif
                            
                                    let lnum = s:find_start_of_block(a:lnum - 1, blocks)
                                    if lnum > 0
                                        return indent(lnum)
                                    else
                                        return -1
                                    endif
                                endfor
                            
                                return -2
                            endfunction
                            
    2              0.000003 function! s:indent_like_previous_line(lnum)
                                let lnum = prevnonblank(a:lnum - 1)
                            
                                " No previous line, keep current indent.
                                if lnum < 1
                                  return -1
                                endif
                            
                                let text = getline(lnum)
                                let start = s:find_start_of_multiline_statement(lnum)
                                let base = indent(start)
                                let current = indent(a:lnum)
                            
                                " Jump to last character in previous line.
                                call cursor(lnum, len(text))
                                let ignore_last_char = eval(s:skip_special_chars)
                            
                                " Search for final colon that is not inside something to be ignored.
                                while 1
                                    let curpos = getpos(".")[2]
                                    if curpos == 1 | break | endif
                                    if eval(s:skip_special_chars) || text[curpos-1] =~ '\s'
                                        normal! h
                                        continue
                                    elseif text[curpos-1] == ':'
                                        return base + s:sw()
                                    endif
                                    break
                                endwhile
                            
                                if text =~ '\\$' && !ignore_last_char
                                    " If this line is the continuation of a control statement
                                    " indent further to distinguish the continuation line
                                    " from the next logical line.
                                    if getline(start) =~# s:control_statement
                                        return base + s:sw() * 2
                                    endif
                            
                                    " Nest (other) explicit continuations only one level deeper.
                                    return base + s:sw()
                                endif
                            
                                " If the previous statement was a stop-execution statement or a pass
                                if getline(start) =~# s:stop_statement
                                    " Remove one level of indentation if the user hasn't already dedented
                                    if indent(a:lnum) > base - s:sw()
                                        return base - s:sw()
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
                                " If this line is dedented and the number of indent spaces is valid
                                " (multiple of the indentation size), trust the user
                                let dedent_size = current - base
                                if dedent_size < 0 && current % s:sw() == 0
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
                                return base
                            endfunction
                            
                            " Is the syntax at lnum (and optionally cnum) a python string?
    2              0.000005 function! s:is_python_string(lnum, ...)
                                let line = getline(a:lnum)
                                let linelen = len(line)
                                if linelen < 1
                                  let linelen = 1
                                endif
                                let cols = a:0 ? type(a:1) != type([]) ? [a:1] : a:1 : range(1, linelen)
                                for cnum in cols
                                    if match(map(synstack(a:lnum, cnum),
                                                \ 'synIDattr(v:val,"name")'), 'python\S*String') == -1
                                        return 0
                                    end
                                endfor
                                return 1
                            endfunction
                            
    2              0.000004 function! GetPythonPEPIndent(lnum)
                            
                                " First line has indent 0
                                if a:lnum == 1
                                    return 0
                                endif
                            
                                " Multilinestrings: continous, docstring or starting.
                                if s:is_python_string(a:lnum)
                                    if s:is_python_string(a:lnum-1)
                                        " Previous line is (completely) a string.
                                        return s:indent_like_previous_line(a:lnum)
                                    endif
                            
                                    if match(getline(a:lnum-1), '^\s*\%("""\|''''''\)') != -1
                                        " docstring.
                                        return s:indent_like_previous_line(a:lnum)
                                    endif
                            
                                    if s:is_python_string(a:lnum-1, len(getline(a:lnum-1)))
                                        " String started in previous line.
                                        return 0
                                    endif
                                endif
                            
                                " Parens: If we can find an open parenthesis/bracket/brace, line up with it.
                                let indent = s:indent_like_opening_paren(a:lnum)
                                if indent >= -1
                                    return indent
                                endif
                            
                                " Blocks: Match indent of first block of this type.
                                let indent = s:indent_like_block(a:lnum)
                                if indent >= -1
                                    return indent
                                endif
                            
                                return s:indent_like_previous_line(a:lnum)
                            endfunction

SCRIPT  /usr/share/vim/vim80/indent/python.vim
Sourced 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Python
                            " Maintainer:		Bram Moolenaar <Bram@vim.org>
                            " Original Author:	David Bustos <bustos@caltech.edu>
                            " Last Change:		2013 Jul 9
                            
                            " Only load this indent file when no other was loaded.
    2              0.000008 if exists("b:did_indent")
    2              0.000002   finish

SCRIPT  /usr/share/vim/vim80/syntax/python.vim
Sourced 2 times
Total time:   0.001417
 Self time:   0.001417

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2016 Sep 14
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " quit when a syntax file was already loaded.
    2              0.000007 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    2              0.000012 let s:cpo_save = &cpo
    2              0.000012 set cpo&vim
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    2              0.000013 syn keyword pythonStatement	False None True
    2              0.000009 syn keyword pythonStatement	as assert break continue del exec global
    2              0.000008 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    2              0.000010 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    2              0.000004 syn keyword pythonConditional	elif else if
    2              0.000005 syn keyword pythonRepeat	for while
    2              0.000004 syn keyword pythonOperator	and in is not or
    2              0.000006 syn keyword pythonException	except finally raise try
    2              0.000004 syn keyword pythonInclude	from import
    2              0.000005 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
                            " Python 3.5 introduced the use of the same symbol for matrix
                            " multiplication.  We now have to exclude the symbol from being
                            " highlighted when used in that context. Hence, the check that it's
                            " preceded by empty space only (possibly in a docstring/doctest) and
                            " followed by decorator name, optional parenthesized list of arguments,
                            " and the next line with either def, class, or another decorator.
    2              0.000042 syn match   pythonDecorator
                              \ "\%(\%(^\s*\)\%(\%(>>>\|\.\.\.\)\s\+\)\=\)\zs@\%(\s*\h\%(\w\|\.\)*\s*\%((\_\s\{-}[^)]\_.\{-})\s*\)\=\%(#.*\)\=\n\s*\%(\.\.\.\s\+\)\=\%(@\s*\h\|\%(def\|class\)\s\+\)\)\@="
                              \ display nextgroup=pythonDecoratorName skipwhite
                            
                            " A dot must be allowed because of @MyClass.myfunc decorators.
                            " It must be preceded by a decorator symbol and on a separate line from
                            " a function/class it decorates.
    2              0.000024 syn match   pythonDecoratorName
                              \ "\%(@\s*\)\@<=\h\%(\w\|\.\)*\%(\s*\%((\_\s\{-}[^)]\_.\{-})\s*\)\=\%(#.*\)\=\n\)\@="
                              \ contained display nextgroup=pythonFunction skipnl
                            
                            " The zero-length non-grouping match of def or class before the function
                            " name is extremely important in pythonFunction.  Without it, everything
                            " is interpreted as a function inside the contained environment of
                            " doctests.
    2              0.000019 syn match   pythonFunction
                              \ "\%(\%(^\s*\)\%(\%(>>>\|\.\.\.\)\s\+\)\=\%(def\|class\)\s\+\)\@<=\h\w*"
                              \ contained
                            
    2              0.000012 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    2              0.000008 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    2              0.000029 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    2              0.000029 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    2              0.000032 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    2              0.000021 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    2              0.000009 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    2              0.000009 syn match   pythonEscape	"\\\o\{1,3}" contained
    2              0.000008 syn match   pythonEscape	"\\x\x\{2}" contained
    2              0.000011 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    2              0.000010 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    2              0.000007 syn match   pythonEscape	"\\$"
                            
    2              0.000007 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    2              0.000007 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    2              0.000010   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    2              0.000009   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    2              0.000008   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    2              0.000010   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    2              0.000007   syn match   pythonNumber	"\<\d\+[jJ]\>"
    2              0.000008   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    2              0.000026   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    2              0.000012   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    2              0.000002 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    2              0.000005 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    2              0.000007   syn keyword pythonBuiltin	False True None
    2              0.000011   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    2              0.000017   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    2              0.000018   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    2              0.000006   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    2              0.000005   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    2              0.000006   syn keyword pythonBuiltin	help hex id input int isinstance
    2              0.000005   syn keyword pythonBuiltin	issubclass iter len list locals map max
    2              0.000008   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    2              0.000006   syn keyword pythonBuiltin	print property range repr reversed round set
    2              0.000010   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    2              0.000006   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    2              0.000004   syn keyword pythonBuiltin	basestring cmp execfile file
    2              0.000006   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    2              0.000004   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    2              0.000004   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    2              0.000004   syn keyword pythonBuiltin	apply buffer coerce intern
                              " avoid highlighting attributes as builtins
    2              0.000012   syn match   pythonAttribute	/\.\h\w*/hs=s+1 contains=ALLBUT,pythonBuiltin transparent
    2              0.000002 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    2              0.000006 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    2              0.000006   syn keyword pythonExceptions	BaseException Exception
    2              0.000004   syn keyword pythonExceptions	ArithmeticError BufferError
    2              0.000004   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    2              0.000005   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    2              0.000004   syn keyword pythonExceptions	AssertionError AttributeError
    2              0.000005   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    2              0.000004   syn keyword pythonExceptions	ImportError IndentationError
    2              0.000005   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    2              0.000005   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    2              0.000004   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    2              0.000006   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    2              0.000006   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    2              0.000004   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    2              0.000004   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    2              0.000004   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    2              0.000004   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    2              0.000005   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    2              0.000005   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    2              0.000005   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    2              0.000014   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    2              0.000027   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    2              0.000017   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    2              0.000015   syn keyword pythonExceptions	PermissionError ProcessLookupError
    2              0.000015   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    2              0.000009   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    2              0.000020   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    2              0.000020   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    2              0.000014   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    2              0.000020   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    2              0.000014   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    2              0.000010   syn keyword pythonExceptions	ResourceWarning
    2              0.000002 endif
                            
    2              0.000006 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    2              0.000006 if !exists("python_no_doctest_highlight")
    2              0.000005   if !exists("python_no_doctest_code_highlight")
    2              0.000024     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,@Spell
    2              0.000020     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    2              0.000002   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    2              0.000002 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    2              0.000014 syn sync match pythonSync grouphere NONE "^\s*\%(def\|class\)\s\+\h\w*\s*("
                            
                            " The default highlight links.  Can be overridden later.
    2              0.000011 hi def link pythonStatement		Statement
    2              0.000005 hi def link pythonConditional		Conditional
    2              0.000005 hi def link pythonRepeat		Repeat
    2              0.000005 hi def link pythonOperator		Operator
    2              0.000005 hi def link pythonException		Exception
    2              0.000005 hi def link pythonInclude		Include
    2              0.000004 hi def link pythonAsync			Statement
    2              0.000005 hi def link pythonDecorator		Define
    2              0.000005 hi def link pythonDecoratorName		Function
    2              0.000006 hi def link pythonFunction		Function
    2              0.000006 hi def link pythonComment		Comment
    2              0.000004 hi def link pythonTodo			Todo
    2              0.000006 hi def link pythonString		String
    2              0.000004 hi def link pythonRawString		String
    2              0.000004 hi def link pythonQuotes		String
    2              0.000004 hi def link pythonTripleQuotes		pythonQuotes
    2              0.000006 hi def link pythonEscape		Special
    2              0.000005 if !exists("python_no_number_highlight")
    2              0.000004   hi def link pythonNumber		Number
    2              0.000002 endif
    2              0.000004 if !exists("python_no_builtin_highlight")
    2              0.000006   hi def link pythonBuiltin		Function
    2              0.000001 endif
    2              0.000005 if !exists("python_no_exception_highlight")
    2              0.000004   hi def link pythonExceptions		Structure
    2              0.000002 endif
    2              0.000009 if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
                            endif
    2              0.000004 if !exists("python_no_doctest_highlight")
    2              0.000005   hi def link pythonDoctest		Special
    2              0.000004   hi def link pythonDoctestValue	Define
    2              0.000002 endif
                            
    2              0.000006 let b:current_syntax = "python"
                            
    2              0.000015 let &cpo = s:cpo_save
    2              0.000024 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

FUNCTION  3()
Called 14 times
Total time:   0.000582
 Self time:   0.000421

count  total (s)   self (s)
   14              0.000032     let prependCWD = 0
   14   0.000220   0.000059     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
   14              0.000098         let prependCWD = a:str !~# '^/'
   14              0.000015     endif
                            
   14              0.000034     let toReturn = a:str
   14              0.000018     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
   14              0.000020     return toReturn

FUNCTION  syntastic#log#debug()
Called 76 times
Total time:   0.000524
 Self time:   0.000342

count  total (s)   self (s)
   76   0.000435   0.000253     if !s:_isDebugEnabled(a:level)
   76              0.000053         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 48 times
Total time:   0.030739
 Self time:   0.001935

count  total (s)   self (s)
  131              0.000320     for Fn in a:list
  130   0.029765   0.000961       let code = call(Fn, a:000)
  130              0.000192       if code != 0
   47              0.000066         return code
                                  endif
   83              0.000102     endfor
    1              0.000001     return 0

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 945 times
Total time:   0.003731
 Self time:   0.003731

count  total (s)   self (s)
  945              0.001100   if a:text ==# 'added'
  705              0.000633     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
  225              0.000217     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
   15              0.000017     return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 21 times
Total time:   0.000415
 Self time:   0.000165

count  total (s)   self (s)
   21   0.000405   0.000155   return 'cd ' . gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()) . ' && ' . a:cmd

FUNCTION  <SNR>49_BufEnterHook()
Called 8 times
Total time:   0.004412
 Self time:   0.000311

count  total (s)   self (s)
    8   0.000187   0.000113     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) . ', &buftype = ' . string(&buftype))
    8              0.000012     if &buftype ==# ''
    6   0.004071   0.000044         call s:notifiers.refresh(g:SyntasticLoclist.current())
    6              0.000006     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if get(w:, 'syntastic_loclist_set', 0) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  <SNR>62_Highlight_Matching_Pair()
Called 211 times
Total time:   0.038576
 Self time:   0.038576

count  total (s)   self (s)
                              " Remove any previous match.
  211              0.001703   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000012     silent! call matchdelete(3)
    2              0.000007     let w:paren_hl_on = 0
    2              0.000002   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  211              0.002261   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  211              0.000873   let c_lnum = line('.')
  211              0.000636   let c_col = col('.')
  211              0.000396   let before = 0
                            
  211              0.000765   let text = getline(c_lnum)
  211              0.006909   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  211              0.000648   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  211              0.001197     let [c_before, c] = matches[1:2]
  211              0.000209   endif
  211              0.011330   let plist = split(&matchpairs, '.\zs[:,]')
  211              0.000826   let i = index(plist, c)
  211              0.000288   if i < 0
                                " not found, in Insert mode try character before the cursor
  209              0.000804     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   90              0.000286       let before = strlen(c_before)
   90              0.000147       let c = c_before
   90              0.000217       let i = index(plist, c)
   90              0.000081     endif
  209              0.000254     if i < 0
                                  " not found, nothing to do
  209              0.000255       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000005   if i % 2 == 0
    2              0.000006     let s_flags = 'nW'
    2              0.000013     let c2 = plist[i + 1]
    2              0.000004   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    2              0.000006   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000005   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    2              0.000017   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    2              0.001105   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    2              0.000014   let stoplinebottom = line('w$')
    2              0.000009   let stoplinetop = line('w0')
    2              0.000005   if i % 2 == 0
    2              0.000013     let stopline = stoplinebottom
    2              0.000004   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000012   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    2              0.000018     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000003   endif
    2              0.000006   try
    2              0.000988     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    2              0.000009   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    2              0.000005   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    2              0.000012   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000014     if exists('*matchaddpos')
    2              0.000068       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    2              0.000004     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    2              0.000008     let w:paren_hl_on = 1
    2              0.000004   endif

FUNCTION  gitgutter#utility#system()
Called 21 times
Total time:   1.090305
 Self time:   0.002460

count  total (s)   self (s)
   21   0.000397   0.000064   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
   21   1.089326   0.001814     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
   21              0.000173   endif
   21              0.000096   return output

FUNCTION  gitgutter#sign#remove_signs()
Called 18 times
Total time:   0.000481
 Self time:   0.000455

count  total (s)   self (s)
   18   0.000095   0.000069   let bufnr = gitgutter#utility#bufnr()
   18              0.000061   if a:all_signs && s:supports_star && empty(getbufvar(bufnr, 'gitgutter_other_signs'))
    3              0.000017     let dummy_sign_present = getbufvar(bufnr, 'gitgutter_dummy_sign')
    3              0.000025     execute "sign unplace * buffer=" . bufnr
    3              0.000005     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
    3              0.000003   else
   15              0.000039     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
   15              0.000012   endif

FUNCTION  <SNR>52_invoke_funcrefs()
Called 47 times
Total time:   0.164516
 Self time:   0.002261

count  total (s)   self (s)
   47   0.001707   0.000295   let builder = airline#builder#new(a:context)
   47   0.031232   0.000503   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   47              0.000079   if err == 1
   47   0.130520   0.000406     let a:context.line = builder.build()
   47              0.000346     let s:contexts[a:context.winnr] = a:context
   47              0.000481     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   47              0.000042   endif

FUNCTION  syntastic#log#debugShowOptions()
Called 2 times
Total time:   0.000011
 Self time:   0.000007

count  total (s)   self (s)
    2   0.000008   0.000004     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  <SNR>51_on_colorscheme_changed()
Called 1 time
Total time:   0.230376
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000012   0.000007   call s:init()
    1              0.000001   if !s:airline_theme_defined
    1   0.000137   0.000007     if airline#switch_matching_theme()
                                  return
                                endif
    1              0.000000   endif
                            
                              " couldn't find a match, or theme was defined, just refresh
    1   0.230221   0.000008   call airline#load_theme()

FUNCTION  airline#check_mode()
Called 551 times
Total time:   1.032039
 Self time:   0.517829

count  total (s)   self (s)
  551              0.002422   let context = s:contexts[a:winnr]
                            
  551              0.001894   if get(w:, 'airline_active', 1)
  489              0.001570     let l:m = mode()
  489              0.000879     if l:m ==# "i"
   53              0.000125       let l:mode = ['insert']
   53              0.000064     elseif l:m ==# "R"
    1              0.000002       let l:mode = ['replace']
    1              0.000001     elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  435              0.001040       let l:mode = ['normal']
  435              0.000398     endif
  489              0.002477     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  489              0.000445   else
   62              0.000153     let l:mode = ['inactive']
   62              0.000277     let w:airline_current_mode = get(g:airline_mode_map, '__')
   62              0.000060   endif
                            
  551              0.001687   if g:airline_detect_modified && &modified
  376              0.001458     call add(l:mode, 'modified')
  376              0.000309   endif
                            
  551              0.000990   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  551              0.002415   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  551              0.000798   if &readonly || ! &modifiable
   49              0.000187     call add(l:mode, 'readonly')
   49              0.000033   endif
                            
  551              0.470100   let mode_string = join(l:mode)
  551              0.001914   if get(w:, 'airline_lastmode', '') != mode_string
   37   0.005040   0.002224     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   37   0.511689   0.000295     call airline#highlighter#highlight(l:mode)
   37              0.000105     let w:airline_lastmode = mode_string
   37              0.000026   endif
                            
  551              0.000626   return ''

FUNCTION  <SNR>83_get_prev_group()
Called 297 times
Total time:   0.004062
 Self time:   0.004062

count  total (s)   self (s)
  297              0.000735   let x = a:i - 1
  342              0.000537   while x >= 0
  295              0.000830     let group = a:sections[x][0]
  295              0.000613     if group != '' && group != '|'
  250              0.000326       return group
                                endif
   45              0.000070     let x = x - 1
   45              0.000038   endwhile
   47              0.000054   return ''

FUNCTION  5()
Called 5 times
Total time:   0.000318
 Self time:   0.000173

count  total (s)   self (s)
    5   0.000074   0.000019     let self.cachedDisplayString = self.flagSet.renderToString()
                            
    5   0.000085   0.000023     let self.cachedDisplayString .= self.getLastPathComponent(1)
                            
    5              0.000003     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
    5              0.000009     let self._bookmarkNames = []
    5   0.000046   0.000018     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
    5              0.000008     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
    5              0.000004     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
    5              0.000004     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' [RO]'
                                endif

FUNCTION  airline#util#append()
Called 1892 times
Total time:   0.019838
 Self time:   0.019838

count  total (s)   self (s)
 1892              0.004146   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1892              0.005943   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1892              0.005322   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>85__isDebugEnabled_smart()
Called 84 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   84              0.000184     return and(g:syntastic_debug, a:level)

FUNCTION  airline#themes#get_highlight()
Called 1290 times
Total time:   0.335478
 Self time:   0.007203

count  total (s)   self (s)
 1290   0.335109   0.006834   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>49_UpdateErrors()
Called 2 times
Total time:   0.003578
 Self time:   0.000253

count  total (s)   self (s)
    2   0.000026   0.000013     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    2   0.000022   0.000011     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    2   0.000021   0.000011     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    2   0.000025   0.000015     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    2   0.000046   0.000010     call s:modemap.synch()
                            
    2   0.000165   0.000007     if s:_skip_file()
                                    return
                                endif
                            
    2   0.000088   0.000011     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    2              0.000002     if run_checks
    2   0.001688   0.000014         call s:CacheErrors(a:checker_names)
    2              0.000003         unlockvar! b:syntastic_changedtick
    2              0.000005         let b:syntastic_changedtick = b:changedtick
    2              0.000013         lockvar! b:syntastic_changedtick
    2              0.000002     else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
    2   0.000025   0.000009     let loclist = g:SyntasticLoclist.current()
                            
    2              0.000004     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    2   0.000036   0.000010     let do_jump = syntastic#util#var('auto_jump') + 0
    2              0.000003     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    2              0.000003     let w:syntastic_loclist_set = 0
    2   0.000019   0.000005     if syntastic#util#var('always_populate_loc_list') || do_jump
    2   0.000020   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
    2   0.000015   0.000012         call setloclist(0, loclist.getRaw())
    2              0.000004         let w:syntastic_loclist_set = 1
    2              0.000004         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    2              0.000001     endif
                                " }}}3
                            
    2   0.001279   0.000014     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>49_BufReadPostHook()
Called 2 times
Total time:   0.003643
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000003     if g:syntastic_check_on_open
    2   0.000045   0.000026         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
    2   0.003592   0.000014         call s:UpdateErrors(1, [])
    2              0.000002     endif

FUNCTION  <SNR>36_activateFileNode()
Called 2 times
Total time:   0.183474
 Self time:   0.000028

count  total (s)   self (s)
    2   0.183473   0.000027     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  <SNR>15_SynSet()
Called 5 times
Total time:   0.003605
 Self time:   0.001401

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    5              0.000018   syn clear
    5              0.000014   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    5              0.000014   let s = expand("<amatch>")
    5              0.000005   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    5              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    8              0.000026     for name in split(s, '\.')
    4   0.003425   0.001221       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.000006     endfor
    4              0.000003   endif

FUNCTION  gitgutter#highlight#get_background_colors()
Called 2 times
Total time:   0.000162
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000006   redir => highlight
    2              0.000021   silent execute 'silent highlight ' . a:group
    2              0.000004   redir END
                            
    2              0.000021   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
    2              0.000003   if len(link_matches) > 0 " follow the link
    1              0.000005     return gitgutter#highlight#get_background_colors(link_matches[1])
                              endif
                            
    1   0.000020   0.000008   let ctermbg = gitgutter#highlight#match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
    1   0.000013   0.000004   let guibg   = gitgutter#highlight#match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
    1              0.000002   return [guibg, ctermbg]

FUNCTION  gitgutter#sign#find_current_signs()
Called 18 times
Total time:   0.045667
 Self time:   0.045633

count  total (s)   self (s)
   18   0.000131   0.000097   let bufnr = gitgutter#utility#bufnr()
   18              0.000056   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
   18              0.000034   let other_signs = []      " [<line_number (number),...]
   18              0.000034   let dummy_sign_placed = 0
                            
   18              0.000075   redir => signs
   18              0.001312     silent execute "sign place buffer=" . bufnr
   18              0.000065   redir END
                            
  963              0.002628   for sign_line in filter(split(signs, '\n'), 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
  945              0.009926     let components  = split(sign_line)
  945              0.003550     let name        = split(components[2], '=')[1]
  945              0.002549     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
  945              0.003696       let line_number = str2nr(split(components[0], '=')[1])
  945              0.002074       if name =~# 'GitGutter'
  945              0.003488         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
  945              0.001754         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
  945              0.003316         let gitgutter_signs[line_number] = {'id': id, 'name': name}
  945              0.000604       else
                                    call add(other_signs, line_number)
                                  endif
  945              0.000523     end
  945              0.001776   endfor
                            
   18              0.000126   call setbufvar(bufnr, 'gitgutter_dummy_sign', dummy_sign_placed)
   18              0.000403   call setbufvar(bufnr, 'gitgutter_gitgutter_signs', gitgutter_signs)
   18              0.000070   call setbufvar(bufnr, 'gitgutter_other_signs', other_signs)

FUNCTION  <SNR>9_BMTruncName()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000001   let name = a:fname
    1              0.000002   if g:bmenu_max_pathlen < 5
                                let name = ""
                              else
    1              0.000002     let len = strlen(name)
    1              0.000001     if len > g:bmenu_max_pathlen
                                  let amountl = (g:bmenu_max_pathlen / 2) - 2
                                  let amountr = g:bmenu_max_pathlen - amountl - 3
                                  let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
                                  let left = substitute(name, pattern, '\1', '')
                                  let right = substitute(name, pattern, '\2', '')
                                  if strlen(left) + strlen(right) < len
                            	let name = left . '...' . right
                                  endif
                                endif
    1              0.000001   endif
    1              0.000001   return name

FUNCTION  airline#parts#filetype()
Called 502 times
Total time:   0.001087
 Self time:   0.001087

count  total (s)   self (s)
  502              0.000910   return &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 18 times
Total time:   0.000394
 Self time:   0.000394

count  total (s)   self (s)
   18              0.000086   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 473 times
Total time:   0.003129
 Self time:   0.003129

count  total (s)   self (s)
  473              0.001220   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  473              0.000404   return ''

FUNCTION  gitgutter#highlight#define_highlights()
Called 1 time
Total time:   0.000193
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000111   0.000009   let [guibg, ctermbg] = gitgutter#highlight#get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
    1              0.000010   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
    1              0.000008   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
    1              0.000006   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
    1              0.000003   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
                            
    1              0.000007   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000008   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000007   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000003   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisble
                            
    1              0.000003   highlight default link GitGutterAdd          GitGutterAddDefault
    1              0.000003   highlight default link GitGutterChange       GitGutterChangeDefault
    1              0.000002   highlight default link GitGutterDelete       GitGutterDeleteDefault
    1              0.000003   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
                            
                              " Highlights used for the whole line.
                            
    1              0.000003   highlight default link GitGutterAddLine          DiffAdd
    1              0.000002   highlight default link GitGutterChangeLine       DiffChange
    1              0.000002   highlight default link GitGutterDeleteLine       DiffDelete
    1              0.000002   highlight default link GitGutterChangeDeleteLine GitGutterChangeLineDefault

FUNCTION  gitgutter#process_buffer()
Called 28 times
Total time:   1.232440
 Self time:   0.002860

count  total (s)   self (s)
   28   0.000497   0.000145   call gitgutter#utility#set_buffer(a:bufnr)
   28   0.001193   0.000177   if gitgutter#utility#is_active()
   20              0.000044     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
   20              0.000034     try
   20   0.000084   0.000066       if !a:realtime || gitgutter#utility#has_fresh_changes()
   20   1.096795   0.000471         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 1)
   18   0.022686   0.000341         call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(diff))
   18   0.030315   0.000272         let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
   18              0.000062         if len(modified_lines) > g:gitgutter_max_signs
                                      call gitgutter#utility#warn('exceeded maximum number of signs (configured by g:gitgutter_max_signs).')
                                      call gitgutter#sign#clear_signs()
                                      return
                                    endif
                            
   18              0.000034         if g:gitgutter_signs || g:gitgutter_highlight_lines
   18   0.079407   0.000129           call gitgutter#sign#update_signs(modified_lines)
   18              0.000012         endif
                            
   18   0.000253   0.000106         call gitgutter#utility#save_last_seen_change()
   18              0.000016       endif
   18              0.000029     catch /diff failed/
    2   0.000036   0.000011       call gitgutter#hunk#reset()
    2              0.000004     endtry
   20              0.000016   else
    8   0.000067   0.000035     call gitgutter#hunk#reset()
    8              0.000006   endif

FUNCTION  <SNR>75_get_hunks()
Called 261 times
Total time:   0.012100
 Self time:   0.006336

count  total (s)   self (s)
  261              0.000643   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let s:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let s:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
  261   0.007406   0.001642   return {s:source_func}()

FUNCTION  307()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000004     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    2              0.000004         let self._mode = 'active'
    2              0.000004         let self._activeFiletypes = []
    2              0.000004         let self._passiveFiletypes = []
    2              0.000002     endif

FUNCTION  308()
Called 2 times
Total time:   0.000050
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000010     let fts = split(a:filetype, '\m\.')
                            
    2   0.000009   0.000005     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    2   0.000024   0.000008         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  309()
Called 2 times
Total time:   0.000077
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000006     let local_mode = get(b:, 'syntastic_mode', '')
    2              0.000004     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    2   0.000061   0.000011     return self.allowsAutoChecking(&filetype)

FUNCTION  airline#extensions#apply()
Called 47 times
Total time:   0.006753
 Self time:   0.002945

count  total (s)   self (s)
   47              0.000180   let s:active_winnr = winnr()
                            
   47   0.003255   0.000249   if s:is_excluded_window()
                                return -1
                              endif
                            
   47              0.000131   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   47              0.000070   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   47              0.000385   if has_key(s:filetype_overrides, &ft)
    4              0.000023     let args = s:filetype_overrides[&ft]
    4   0.000856   0.000054     call airline#extensions#apply_left_override(args[0], args[1])
    4              0.000005   endif
                            
   47              0.000204   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  gitgutter#diff#is_added()
Called 285 times
Total time:   0.000549
 Self time:   0.000549

count  total (s)   self (s)
  285              0.000467   return a:from_count == 0 && a:to_count > 0

FUNCTION  14()
Called 12 times
Total time:   0.000396
 Self time:   0.000078

count  total (s)   self (s)
   12              0.000021     if self.cachedDisplayString ==# ""
    5   0.000333   0.000015         call self.cacheDisplayString()
    5              0.000004     endif
                            
   12              0.000014     return self.cachedDisplayString

FUNCTION  15()
Called 2 times
Total time:   0.172860
 Self time:   0.000960

count  total (s)   self (s)
    2   0.172859   0.000959     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  16()
Called 14 times
Total time:   0.000453
 Self time:   0.000334

count  total (s)   self (s)
   14   0.000168   0.000049     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   14              0.000065         let self.drive = ''
   14              0.000015     endif
                            

FUNCTION  18()
Called 3 times
Total time:   0.000047
 Self time:   0.000024

count  total (s)   self (s)
    3   0.000032   0.000009     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
    3              0.000005     return " \\`\|\"#%&,?()\*^<>[]"

FUNCTION  syntastic#util#stamp()
Called 18 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
   18              0.000257     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  102()
Called 2 times
Total time:   0.183446
 Self time:   0.000042

count  total (s)   self (s)
    2   0.183443   0.000039     call self.open(a:0 ? a:1 : {})

FUNCTION  108()
Called 12 times
Total time:   0.000440
 Self time:   0.000044

count  total (s)   self (s)
   12   0.000438   0.000042     return self.path.displayString()

FUNCTION  109()
Called 1 time
Total time:   0.000177
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000176   0.000006     return self.path.str() ==# a:treenode.path.str()

FUNCTION  <SNR>36_activateDirNode()
Called 1 time
Total time:   0.013137
 Self time:   0.000012

count  total (s)   self (s)
    1   0.013136   0.000011     call a:node.activate()

FUNCTION  gitgutter#utility#shellescape()
Called 44 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
   44              0.000346   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   44              0.000058     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  310()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000004     return self._mode ==# 'passive'

FUNCTION  315()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000015     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  317()
Called 8 times
Total time:   0.005237
 Self time:   0.001888

count  total (s)   self (s)
    8   0.000054   0.000035     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    8   0.000082   0.000033     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   48              0.000068     for type in self._enabled_types
   40              0.000319         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   40   0.000634   0.000257         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   40              0.000111             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
   16              0.000053                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
   16   0.000636   0.000112                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
   16   0.001076   0.000071                     call self._notifier[type].refresh(a:loclist)
   16   0.000327   0.000096                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
   16              0.000014                 endif
   16              0.000010             else
   24   0.001249   0.000105                 call self._notifier[type].refresh(a:loclist)
   24              0.000020             endif
   40              0.000021         endif
   40              0.000032     endfor

FUNCTION  318()
Called 2 times
Total time:   0.000416
 Self time:   0.000273

count  total (s)   self (s)
    2   0.000019   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   12              0.000014     for type in self._enabled_types
   10              0.000069         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   10              0.000036         if has_key(g:{class}, 'reset')
    6   0.000162   0.000032             call self._notifier[type].reset(a:loclist)
    6              0.000005         endif
                            
                                    " also reset stamps
   10              0.000022         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    4              0.000015             let b:syntastic_private_{type}_stamp = []
    4              0.000003         endif
   10              0.000007     endfor

FUNCTION  <SNR>47__normalise_filetype()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000009     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    2              0.000006     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000007     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000001     return ft

FUNCTION  21()
Called 73 times
Total time:   0.001058
 Self time:   0.001058

count  total (s)   self (s)
   73              0.000181     if empty(self.pathSegments)
                                    return ''
                                endif
   73              0.000218     let toReturn = self.pathSegments[-1]
   73              0.000135     if a:dirSlash && self.isDirectory
   12              0.000031         let toReturn = toReturn . '/'
   12              0.000011     endif
   73              0.000121     return toReturn

FUNCTION  22()
Called 5 times
Total time:   0.000377
 Self time:   0.000217

count  total (s)   self (s)
    5              0.000011     let i = 0
   10              0.000035     while i < len(g:NERDTreeSortOrder)
    9   0.000265   0.000105         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
    4              0.000008             return i
                                    endif
    5              0.000016         let i = i + 1
    5              0.000006     endwhile
    1              0.000002     return s:NERDTreeSortStarIndex

FUNCTION  23()
Called 26 times
Total time:   0.001167
 Self time:   0.000697

count  total (s)   self (s)
   26              0.000083     if !exists("self._sortKey")
    5   0.000122   0.000029         let path = self.getLastPathComponent(1)
    5              0.000012         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
    5              0.000011         if !g:NERDTreeCaseSensitiveSort
    5              0.000021             let path = tolower(path)
    5              0.000006         endif
    5   0.000429   0.000052         let self._sortKey = printf(s:sortKeyFormat, self.getSortOrderIndex()) . path
    5              0.000006     endif
                            
   26              0.000044     return self._sortKey

FUNCTION  24()
Called 20 times
Total time:   0.000395
 Self time:   0.000135

count  total (s)   self (s)
   20   0.000389   0.000129     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
Called 20 times
Total time:   0.002333
 Self time:   0.000883

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   20              0.000038     if b:NERDTreeIgnoreEnabled
   40              0.000076         for i in g:NERDTreeIgnore
   20   0.000975   0.000081             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
   20              0.000021         endfor
                            
   20   0.000252   0.000091         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': b:NERDTree})
                                            return 1
                                        endif
                                    endfor
   20              0.000020     endif
                            
                                "dont show hidden files unless instructed to
   20   0.000485   0.000090     if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
    3              0.000004         return 1
                                endif
                            
   17              0.000041     if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
   17              0.000014     return 0

FUNCTION  27()
Called 20 times
Total time:   0.000894
 Self time:   0.000628

count  total (s)   self (s)
   20              0.000050     let pat = a:pattern
   20              0.000081     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
   20   0.000417   0.000151     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>79_get_syn()
Called 3148 times
Total time:   0.082060
 Self time:   0.082060

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
 3148              0.014194   let mode = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? 'gui' : 'cterm'
 3148              0.017439   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
 3148              0.006177   if empty(color) || color == -1
  243              0.001398     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
  243              0.000203   endif
 3148              0.005522   if empty(color) || color == -1
                                if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
 3148              0.003176   return color

FUNCTION  110()
Called 21 times
Total time:   0.003136
 Self time:   0.000106

count  total (s)   self (s)
   21   0.003086   0.000056     if a:path.equals(self.path)
    6              0.000006         return self
                                endif
   15              0.000012     return {}

FUNCTION  114()
Called 9 times
Total time:   0.032589
 Self time:   0.000233

count  total (s)   self (s)
    9              0.000022     try
    9   0.010023   0.000080         let path = b:NERDTree.ui.getPath(line("."))
    9              0.000017         if path ==# {}
                                        return {}
                                    endif
    9   0.022463   0.000050         return b:NERDTreeRoot.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  116()
Called 1 time
Total time:   0.000192
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000007   0.000004     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
    1   0.000181   0.000004     return self.equals(b:NERDTreeRoot)

FUNCTION  118()
Called 5 times
Total time:   0.000344
 Self time:   0.000085

count  total (s)   self (s)
    5              0.000010     if a:path.isDirectory
    4   0.000291   0.000032         return g:NERDTreeDirNode.New(a:path)
                                else
    1              0.000025         let newTreeNode = copy(self)
    1              0.000004         let newTreeNode.path = a:path
    1              0.000003         let newTreeNode.parent = {}
    1              0.000002         return newTreeNode
                                endif

FUNCTION  119()
Called 2 times
Total time:   0.183404
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000004     let opts = a:0 ? a:1 : {}
    2   0.000120   0.000015     let opener = g:NERDTreeOpener.New(self.path, opts)
    2   0.183277   0.000013     call opener.open(self)

FUNCTION  322()
Called 2 times
Total time:   0.000150
 Self time:   0.000081

count  total (s)   self (s)
    2   0.000038   0.000013     let ft = s:_normalise_filetype(a:ftalias)
    2   0.000017   0.000009     call self._loadCheckersFor(ft)
                            
    2              0.000006     let checkers_map = self._checkerMap[ft]
    2              0.000003     if empty(checkers_map)
                                    return []
                                endif
                            
    2   0.000025   0.000006     call self._checkDeprecation(ft)
                            
    2              0.000019     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
    2   0.000032   0.000015     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  329()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000017     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  30()
Called 78 times
Total time:   0.012574
 Self time:   0.000421

count  total (s)   self (s)
   78   0.012563   0.000410     return self.str() ==# a:path.str()

FUNCTION  31()
Called 14 times
Total time:   0.004756
 Self time:   0.000686

count  total (s)   self (s)
   14              0.000357     let newPath = copy(self)
                            
   14   0.004056   0.000134     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
   14              0.000058     let newPath.cachedDisplayString = ""
   14   0.000228   0.000080     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
   14              0.000018     return newPath

FUNCTION  32()
Called 546 times
Total time:   0.004649
 Self time:   0.001434

count  total (s)   self (s)
  546   0.004540   0.001325     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  33()
Called 28 times
Total time:   0.000697
 Self time:   0.000697

count  total (s)   self (s)
   28              0.000310     let tmp = resolve(a:path)
   28              0.000366     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
Called 14 times
Total time:   0.003340
 Self time:   0.001661

count  total (s)   self (s)
   14   0.000527   0.000074     call self.extractDriveLetter(a:fullpath)
                            
   14   0.000264   0.000076     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   14              0.000115     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   14              0.000156     let self.pathSegments = split(fullpath, '/')
                            
   14              0.000050     let self.isReadOnly = 0
   14              0.000061     if isdirectory(a:fullpath)
    7              0.000029         let self.isDirectory = 1
    7              0.000019     elseif filereadable(a:fullpath)
    7              0.000021         let self.isDirectory = 0
    7              0.000047         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    7              0.000006     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   14              0.000049     let self.isExecutable = 0
   14              0.000024     if !self.isDirectory
    7              0.000036         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    7              0.000005     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   14   0.000298   0.000081     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   14   0.000604   0.000131     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   14   0.000465   0.000117     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   14              0.000023     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  38()
Called 287 times
Total time:   0.022590
 Self time:   0.011306

count  total (s)   self (s)
  287              0.000598     let options = a:0 ? a:1 : {}
  287              0.000383     let toReturn = ""
                            
  287              0.000500     if has_key(options, 'format')
   15              0.000035         let format = options['format']
   15              0.000048         if has_key(self, '_strFor' . format)
   15   0.000428   0.000123             exec 'let toReturn = self._strFor' . format . '()'
   15              0.000017         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   15              0.000013     else
  272   0.010668   0.000837         let toReturn = self._str()
  272              0.000221     endif
                            
  287   0.001811   0.000988     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
  287              0.000479     if has_key(options, 'truncateTo')
    1              0.000003         let limit = options['truncateTo']
    1              0.000005         if len(toReturn) > limit-1
    1              0.000007             let toReturn = toReturn[(len(toReturn)-limit+1):]
    1              0.000012             if len(split(toReturn, '/')) > 1
    1              0.000015                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
    1              0.000001             else
                                            let toReturn = '<' . toReturn
                                        endif
    1              0.000001         endif
    1              0.000001     endif
                            
  287              0.000278     return toReturn

FUNCTION  39()
Called 12 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   12              0.000061     let toReturn = '/' . join(self.pathSegments, '/')
   12              0.000025     if self.isDirectory && toReturn != '/'
   12              0.000026         let toReturn  = toReturn . '/'
   12              0.000010     endif
   12              0.000014     return toReturn

FUNCTION  <SNR>36_handleLeftClick()
Called 3 times
Total time:   0.009787
 Self time:   0.000315

count  total (s)   self (s)
    3   0.009497   0.000029     let currentNode = g:NERDTreeFileNode.GetSelected()
    3              0.000004     if currentNode != {}
                            
                                    "the dir arrows are multibyte chars, and vim's string functions only
                                    "deal with single bytes - so split the line up with the hack below and
                                    "take the line substring manually
    3              0.000056         let line = split(getline(line(".")), '\zs')
    3              0.000004         let startToCur = ""
   35              0.000040         for i in range(0,len(line)-1)
   32              0.000059             let startToCur .= line[i]
   32              0.000019         endfor
                            
    3              0.000004         if currentNode.path.isDirectory
    1   0.000018   0.000014             if startToCur =~# g:NERDTreeUI.MarkupReg() && startToCur =~# '[+~▾▸] \?$'
                                            call currentNode.activate()
                                            return
                                        endif
    1              0.000001         endif
                            
    3              0.000009         if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                        let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                        if char !~# g:NERDTreeUI.MarkupReg()
                                            if currentNode.path.isDirectory
                                                call currentNode.activate()
                                            else
                                                call currentNode.activate({'reuse': 'all', 'where': 'p'})
                                            endif
                                            return
                                        endif
                                    endif
    3              0.000001     endif

FUNCTION  123()
Called 1 time
Total time:   0.000660
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000637   0.000008     let ln = b:NERDTree.ui.getLineNum(self)
    1              0.000001     if ln != -1
    1              0.000001         if a:isJump
                                        mark '
                                    endif
    1              0.000003         call cursor(ln, col("."))
    1              0.000001     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && b:NERDTree.ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call b:NERDTree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  127()
Called 1 time
Total time:   0.005363
 Self time:   0.000016

count  total (s)   self (s)
    1   0.005361   0.000014     return self._renderToString(0, 0, [], self.getChildCount() ==# 1)

FUNCTION  128()
Called 13 times
Total time:   0.011974
 Self time:   0.009171

count  total (s)   self (s)
   13              0.000020     let output = ""
   13              0.000015     if a:drawText ==# 1
                            
   12              0.000018         let treeParts = ''
                            
                                    "get all the leading spaces and vertical tree parts for this line
   12              0.000014         if a:depth > 1
   10              0.000015             for j in a:vertMap[0:-2]
    5              0.000008                 if g:NERDTreeDirArrows
    5              0.000007                     let treeParts = treeParts . '  '
    5              0.000003                 else
                                                if j ==# 1
                                                    let treeParts = treeParts . '| '
                                                else
                                                    let treeParts = treeParts . '  '
                                                endif
                                            endif
    5              0.000006             endfor
    5              0.000003         endif
                            
                                    "get the last vertical tree part for this line which will be different
                                    "if this node is the last child of its parent
   12              0.000015         if !g:NERDTreeDirArrows
                                        if a:isLastChild
                                            let treeParts = treeParts . '`'
                                        else
                                            let treeParts = treeParts . '|'
                                        endif
                                    endif
                            
                                    "smack the appropriate dir/file symbol on the line before the file/dir
                                    "name itself
   12              0.000015         if self.path.isDirectory
    6              0.000006             if self.isOpen
    1              0.000001                 if g:NERDTreeDirArrows
    1              0.000003                     let treeParts = treeParts . '▾ '
    1              0.000001                 else
                                                let treeParts = treeParts . '~'
                                            endif
    1              0.000000             else
    5              0.000006                 if g:NERDTreeDirArrows
    5              0.000007                     let treeParts = treeParts . '▸ '
    5              0.000004                 else
                                                let treeParts = treeParts . '+'
                                            endif
    5              0.000003             endif
    6              0.000004         else
    6              0.000007             if g:NERDTreeDirArrows
    6              0.000009                 let treeParts = treeParts . '  '
    6              0.000004             else
                                            let treeParts = treeParts . '-'
                                        endif
    6              0.000002         endif
   12   0.002447   0.002007         let line = treeParts . self.displayString()
                            
   12              0.000025         let output = output . line . "\n"
   12              0.000005     endif
                            
                                "if the node is an open dir, draw its children
   13              0.000020     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    2   0.001759   0.000010         let childNodesToDraw = self.getVisibleChildren()
    2              0.000004         if len(childNodesToDraw) > 0
                            
                                        "draw all the nodes children except the last
    2              0.000005             let lastIndx = len(childNodesToDraw)-1
    2              0.000002             if lastIndx > 0
   12              0.000018                 for i in childNodesToDraw[0:lastIndx-1]
   10              0.000065                     let output = output . i._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 1), 0)
   10              0.000009                 endfor
    2              0.000002             endif
                            
                                        "draw the last child, indicating that it IS the last
    2              0.000015             let output = output . childNodesToDraw[lastIndx]._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 0), 1)
    2              0.000001         endif
    2              0.000002     endif
                            
   13              0.000013     return output

FUNCTION  330()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000005     if has_key(self._checkerMap, a:filetype)
    2              0.000002         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  331()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000009     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  333()
Called 16 times
Total time:   0.000209
 Self time:   0.000091

count  total (s)   self (s)
   16   0.000207   0.000089     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  334()
Called 8 times
Total time:   0.000803
 Self time:   0.000153

count  total (s)   self (s)
    8   0.000084   0.000030     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
    8   0.000091   0.000035     let old_signs = copy(self._bufSignIds())
    8   0.000112   0.000016     if self.enabled()
    8   0.000381   0.000033         call self._signErrors(a:loclist)
    8              0.000005     endif
    8   0.000123   0.000027     call self._removeSigns(old_signs)

FUNCTION  336()
Called 8 times
Total time:   0.000348
 Self time:   0.000332

count  total (s)   self (s)
    8              0.000015     let loclist = a:loclist
    8   0.000041   0.000025     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  337()
Called 8 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    8              0.000019     if has('signs')
    8              0.000027         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    8              0.000005     endif

FUNCTION  338()
Called 8 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    8              0.000021     if !exists('b:syntastic_private_sign_ids')
    1              0.000002         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
    8              0.000012     return b:syntastic_private_sign_ids

FUNCTION  nerdtree#checkForBrowse()
Called 8 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    8              0.000073     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif

FUNCTION  <SNR>83_get_transitioned_seperator()
Called 171 times
Total time:   0.056847
 Self time:   0.003599

count  total (s)   self (s)
  171              0.000291   let line = ''
  171   0.054244   0.000996   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  171              0.000781   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  171              0.000711   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  171              0.000429   let line .= '%#'.a:group.'#'
  171              0.000221   return line

FUNCTION  <SNR>12_LoadIndent()
Called 2 times
Total time:   0.000992
 Self time:   0.000394

count  total (s)   self (s)
    2              0.000006     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000007     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000004       if exists("b:did_indent")
    1              0.000002 	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000014       for name in split(s, '\.')
    2   0.000932   0.000334 	exe 'runtime! indent/' . name . '.vim'
    2              0.000002       endfor
    2              0.000002     endif

FUNCTION  41()
Called 2 times
Total time:   0.000241
 Self time:   0.000058

count  total (s)   self (s)
    2   0.000208   0.000025     let p = escape(self.str(), self._escChars())
                            
                                "make it relative
    2              0.000011     let p = fnamemodify(p, ':.')
                            
                                "handle the edge case where the file begins with a + (vim interprets
                                "the +foo in `:e +foo` as an option to :edit)
    2              0.000005     if p[0] == "+"
                                    let p = '\' . p
                                endif
                            
    2              0.000002     if p ==# ''
                                    let p = '.'
                                endif
                            
    2              0.000001     return p

FUNCTION  42()
Called 1 time
Total time:   0.000156
 Self time:   0.000066

count  total (s)   self (s)
    1   0.000030   0.000008     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
    1   0.000018   0.000005     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
    1   0.000029   0.000012     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
    1   0.000019   0.000006     if !nerdtree#runningWindows()
    1   0.000046   0.000021         let toReturn = escape(toReturn, self._escChars())
    1              0.000002     endif
    1              0.000002     return toReturn

FUNCTION  43()
Called 272 times
Total time:   0.009831
 Self time:   0.003647

count  total (s)   self (s)
  272   0.003140   0.000752     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
  272   0.002271   0.000697     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
  272   0.003506   0.001284     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  44()
Called 14 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   14              0.000121     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  45()
Called 2 times
Total time:   0.000253
 Self time:   0.000092

count  total (s)   self (s)
    2   0.000169   0.000008     let str = self.str()
    4              0.000009     for t in range(tabpagenr('$'))
    6              0.000012         for b in tabpagebuflist(t+1)
    4              0.000030             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    4              0.000004         endfor
    2              0.000001     endfor
    2              0.000001     return 0

FUNCTION  46()
Called 14 times
Total time:   0.000188
 Self time:   0.000078

count  total (s)   self (s)
   14   0.000156   0.000046     if !nerdtree#runningWindows()
   14              0.000023         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  130()
Called 1 time
Total time:   0.013125
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000005     let opts = a:0 ? a:1 : {}
    1   0.006342   0.000012     call self.toggleOpen(opts)
    1   0.006107   0.000011     call b:NERDTree.render()
    1   0.000670   0.000010     call self.putCursorHere(0, 0)

FUNCTION  131()
Called 5 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    5              0.000027     call add(self.children, a:treenode)
    5              0.000016     let a:treenode.parent = self
                            
    5              0.000010     if a:inOrder
                                    call self.sortChildren()
                                endif

FUNCTION  134()
Called 5 times
Total time:   0.000512
 Self time:   0.000087

count  total (s)   self (s)
    5   0.000382   0.000038     let newTreeNode = g:NERDTreeFileNode.New(a:path)
    5   0.000117   0.000036     call self.addChild(newTreeNode, a:inOrder)
    5              0.000010     return newTreeNode

FUNCTION  136()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     return len(self.children)

FUNCTION  343()
Called 47 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   47              0.000286   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  345()
Called 218 times
Total time:   0.001068
 Self time:   0.001068

count  total (s)   self (s)
  218              0.001000   call add(self._sections, [a:group, a:contents])

FUNCTION  346()
Called 32 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   32              0.000093   call add(self._sections, ['', a:text])

FUNCTION  347()
Called 47 times
Total time:   0.130114
 Self time:   0.025617

count  total (s)   self (s)
   47              0.000097   let side = 1
   47              0.000072   let line = ''
   47              0.000075   let i = 0
   47              0.000149   let length = len(self._sections)
   47              0.000091   let split = 0
                            
  344              0.000583   while i < length
  297              0.000816     let section = self._sections[i]
  297              0.000644     let group = section[0]
  297              0.000657     let contents = section[1]
  297   0.005707   0.001645     let prev_group = s:get_prev_group(self._sections, i)
                            
  297              0.000403     if group == ''
   32              0.000078       let line .= contents
   32              0.000034     elseif group == '|'
   47              0.000073       let side = 0
   47              0.000126       let line .= contents
   47              0.000066       let split = 1
   47              0.000047     else
  218              0.000322       if prev_group == ''
   47              0.000182         let line .= '%#'.group.'#'
   47              0.000063       elseif split
   29   0.009696   0.000210         let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   29              0.000047         let split = 0
   29              0.000029       else
  142   0.081227   0.000952         let line .= s:get_seperator(self, prev_group, group, side)
  142              0.000160       endif
  218   0.012536   0.001862       let line .= s:get_accented_line(self, group, contents)
  218              0.000185     endif
                            
  297              0.000672     let i = i + 1
  297              0.000327   endwhile
                            
   47              0.000073   if !self._context.active
   29              0.007729     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   29              0.000044   endif
   47              0.000076   return line

FUNCTION  gitgutter#diff#parse_diff()
Called 18 times
Total time:   0.021975
 Self time:   0.010934

count  total (s)   self (s)
   18              0.000119   let hunks = []
  304              0.001092   for line in split(a:diff, '\n')
  286   0.012813   0.001772     let hunk_info = gitgutter#diff#parse_hunk(line)
  286              0.000529     if len(hunk_info) == 4
  285              0.000718       call add(hunks, hunk_info)
  285              0.000264     endif
  286              0.006086   endfor
   18              0.000025   return hunks

FUNCTION  gitgutter#diff#is_modified()
Called 195 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
  195              0.000447   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  141()
Called 1 time
Total time:   0.000856
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000855   0.000008     return len(self.getVisibleChildren())

FUNCTION  142()
Called 3 times
Total time:   0.002596
 Self time:   0.000263

count  total (s)   self (s)
    3              0.000008     let toReturn = []
   23              0.000038     for i in self.children
   20   0.002426   0.000093         if i.path.ignore() ==# 0
   17              0.000049             call add(toReturn, i)
   17              0.000014         endif
   20              0.000020     endfor
    3              0.000004     return toReturn

FUNCTION  144()
Called 1 time
Total time:   0.005341
 Self time:   0.000756

count  total (s)   self (s)
                                "remove all the current child nodes
    1              0.000003     let self.children = []
                            
                                "get an array of all the files in the nodes dir
    1              0.000004     let dir = self.path
    1   0.000277   0.000011     let globDir = dir.str({'format': 'Glob'})
                            
    1              0.000002     if version >= 703
    1              0.000213         let filesStr = globpath(globDir, '*', !g:NERDTreeRespectWildIgnore) . "\n" . globpath(globDir, '.*', !g:NERDTreeRespectWildIgnore)
    1              0.000002     else
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                endif
                            
    1              0.000013     let files = split(filesStr, "\n")
                            
    1              0.000006     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
    1              0.000003     let invalidFilesFound = 0
    8              0.000021     for i in files
                            
                                    "filter out the .. and . directories
                                    "Note: we must match .. AND ../ cos sometimes the globpath returns
                                    "../ for path with strange chars (eg $)
                            "        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            "
                                    " Regular expression is too expensive. Use simply string comparison
                                    " instead
    7              0.000113         if i[len(i)-3:2] != ".." && i[len(i)-2:2] != ".." &&  i[len(i)-2:1] != "." && i[len(i)-1] != "."
                                        "put the next file in a new node and attach it
    5              0.000013             try
    5   0.002171   0.000051                 let path = g:NERDTreePath.New(i)
    5   0.000550   0.000038                 call self.createChild(path, 0)
    5   0.000400   0.000056                 call g:NERDTreePathNotifier.NotifyListeners('init', path, {})
    5              0.000012             catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                        endtry
    5              0.000008         endif
    7              0.000011     endfor
                            
    1   0.001349   0.000010     call self.sortChildren()
                            
    1              0.000006     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
    1              0.000002     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
    1   0.000012   0.000008     return self.getChildCount()

FUNCTION  145()
Called 4 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
    4              0.000009     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
    4              0.000165     let newTreeNode = copy(self)
    4              0.000014     let newTreeNode.path = a:path
                            
    4              0.000010     let newTreeNode.isOpen = 0
    4              0.000012     let newTreeNode.children = []
                            
    4              0.000010     let newTreeNode.parent = {}
                            
    4              0.000008     return newTreeNode

FUNCTION  146()
Called 1 time
Total time:   0.005385
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000004     let opts = a:0 ? a:1 : {}
                            
    1              0.000006     if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
    1              0.000005         let self.isOpen = 1
    1              0.000003         if self.children ==# []
    1   0.005355   0.000014             return self._initChildren(0)
                                    else
                                        return 0
                                    endif
                                endif

FUNCTION  147()
Called 1 time
Total time:   0.006292
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000004     let opts = a:0 ? a:1 : {}
    1              0.000003     let level = 0
                            
    1              0.000003     let node = self
    1              0.000004     while node.path.isDirectory
    1   0.005396   0.000011         call node.open(opts)
    1              0.000003         let level += 1
    1   0.000865   0.000009         if node.getVisibleChildCount() == 1
                                        let node = node.getChildByIndex(0, 1)
                                    else
    1              0.000002             break
                                    endif
                                endwhile
    1              0.000001     return level

FUNCTION  gitgutter#diff#process_hunks()
Called 18 times
Total time:   0.029994
 Self time:   0.002486

count  total (s)   self (s)
   18   0.000242   0.000096   call gitgutter#hunk#reset()
   18              0.000057   let modified_lines = []
  303              0.000301   for hunk in a:hunks
  285   0.028759   0.001397     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
  285              0.000445   endfor
   18              0.000021   return modified_lines

FUNCTION  gitgutter#utility#filename()
Called 18 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   18              0.000053   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>9_BMMunge()
Called 1 time
Total time:   0.000067
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000002   let name = a:fname
    1              0.000001   if name == ''
                                if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No file]"
                                endif
                                let name = g:menutrans_no_file
                              else
    1              0.000005     let name = fnamemodify(name, ':p:~')
    1              0.000000   endif
                              " detach file name and separate it out:
    1              0.000002   let name2 = fnamemodify(name, ':t')
    1              0.000002   if a:bnum >= 0
    1              0.000002     let name2 = name2 . ' (' . a:bnum . ')'
    1              0.000001   endif
    1   0.000031   0.000009   let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
    1              0.000004   let name = escape(name, "\\. \t|")
    1              0.000005   let name = substitute(name, "&", "&&", "g")
    1              0.000003   let name = substitute(name, "\n", "^@", "g")
    1              0.000001   return name

FUNCTION  68()
Called 12 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   12              0.000033     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
   12              0.000013     return s:keyMaps

FUNCTION  69()
Called 12 times
Total time:   0.001506
 Self time:   0.001430

count  total (s)   self (s)
  323   0.000368   0.000292     for i in s:KeyMap.All()
  317              0.000482          if i.key ==# a:key && i.scope ==# a:scope
    6              0.000006             return i
                                    endif
  311              0.000191     endfor
    6              0.000006     return {}

FUNCTION  airline#section#create()
Called 4 times
Total time:   0.000725
 Self time:   0.000027

count  total (s)   self (s)
    4   0.000724   0.000026   return s:create(a:parts, 0)

FUNCTION  158()
Called 1 time
Total time:   0.001339
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000008     let CompareFunc = function("nerdtree#compareNodesBySortKey")
    1   0.001330   0.000039     call sort(self.children, CompareFunc)

FUNCTION  159()
Called 1 time
Total time:   0.006330
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     let opts = a:0 ? a:1 : {}
    1              0.000003     if self.isOpen ==# 1
                                    call self.close()
                                else
    1              0.000004         if g:NERDTreeCascadeOpenSingleChildDir == 0
                                        call self.open(opts)
                                    else
    1   0.006303   0.000011             call self.openAlong(opts)
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  airline#extensions#default#apply()
Called 47 times
Total time:   0.021468
 Self time:   0.003019

count  total (s)   self (s)
   47              0.000155   let winnr = a:context.winnr
   47              0.000118   let active = a:context.active
                            
   47   0.000646   0.000404   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   34   0.008232   0.000301     call s:build_sections(a:builder, a:context, s:layout[0])
   34              0.000037   else
   13   0.000668   0.000078     let text = s:get_section(winnr, 'c')
   13              0.000030     if empty(text)
                                  let text = ' %f%m '
                                endif
   13   0.000194   0.000111     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   13              0.000018   endif
                            
   47   0.002696   0.000496   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   47   0.000404   0.000223   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   29   0.007414   0.000192     call s:build_sections(a:builder, a:context, s:layout[1])
   29              0.000023   endif
                            
   47              0.000054   return 1

FUNCTION  <SNR>49_ClearCache()
Called 2 times
Total time:   0.000616
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000490   0.000016     call s:notifiers.reset(g:SyntasticLoclist.current())
    2   0.000126   0.000025     call b:syntastic_loclist.destroy()

FUNCTION  73()
Called 6 times
Total time:   0.206529
 Self time:   0.000131

count  total (s)   self (s)
    6              0.000040     let Callback = function(self.callback)
    6              0.000007     if a:0
    3   0.196653   0.000042         call Callback(a:1)
    3              0.000002     else
    3   0.009803   0.000016         call Callback()
    3              0.000000     endif

FUNCTION  74()
Called 6 times
Total time:   0.231744
 Self time:   0.000480

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    6   0.000105   0.000058     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    6   0.023213   0.000092     let node = g:NERDTreeFileNode.GetSelected()
    6              0.000015     if !empty(node)
                            
                                    "try file node
    6              0.000011         if !node.path.isDirectory
    4   0.000556   0.000032             let km = s:KeyMap.FindFor(a:key, "FileNode")
    4              0.000006             if !empty(km)
    2   0.183533   0.000016                 return km.invoke(node)
                                        endif
    2              0.000002         endif
                            
                                    "try dir node
    4              0.000005         if node.path.isDirectory
    2   0.000326   0.000026             let km = s:KeyMap.FindFor(a:key, "DirNode")
    2              0.000005             if !empty(km)
    1   0.013187   0.000008                 return km.invoke(node)
                                        endif
    1              0.000000         endif
                            
                                    "try generic node
    3   0.000649   0.000013         let km = s:KeyMap.FindFor(a:key, "Node")
    3              0.000003         if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
    3              0.000000     endif
                            
                                "try bookmark
    3   0.000076   0.000015     let bm = g:NERDTreeBookmark.GetSelected()
    3              0.000003     if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
    3   0.000057   0.000011     let km = s:KeyMap.FindFor(a:key, "all")
    3              0.000003     if !empty(km)
    3   0.009844   0.000011         return km.invoke()
                                endif

FUNCTION  79()
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000015     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
    5              0.000006     return g:NERDTreeBookmarks

FUNCTION  161()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000003     let cnt = 0
    1              0.000001     let winnum = 1
    3              0.000003     while 1
    3              0.000017         let bufnum = winbufnr(winnum)
    3              0.000004         if bufnum < 0
    1              0.000001             break
                                    endif
    2              0.000003         if bufnum ==# a:bnum
    1              0.000001             let cnt = cnt + 1
    1              0.000001         endif
    2              0.000005         let winnum = winnum + 1
    2              0.000001     endwhile
                            
    1              0.000001     return cnt

FUNCTION  162()
Called 4 times
Total time:   0.000047
 Self time:   0.000037

count  total (s)   self (s)
    4              0.000005     if self._keepopen
                                    return
                                endif
                            
    4              0.000008     if (a:newtab && self._where == 't') || !a:newtab
    2   0.000019   0.000009         call g:NERDTree.CloseIfQuitOnOpen()
    2              0.000001     endif

FUNCTION  163()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000002     let i = 1
    3              0.000004     while i <= winnr("$")
    2              0.000004         let bnum = winbufnr(i)
    2              0.000011         if bnum != -1 && getbufvar(bnum, '&buftype') ==# '' && !getwinvar(i, '&previewwindow') && (!getbufvar(bnum, '&modified') || &hidden)
                                        return i
                                    endif
                            
    2              0.000003         let i += 1
    2              0.000002     endwhile
    1              0.000001     return -1

FUNCTION  164()
Called 2 times
Total time:   0.009635
 Self time:   0.000067

count  total (s)   self (s)
    2              0.000003     if b:NERDTreeType ==# "secondary"
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    2   0.000022   0.000007         call self._checkToCloseTree(1)
                            
    2              0.000003         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    2   0.009527   0.000006             call self._previousWindow()
    2              0.000002         endif
                            
    2   0.000042   0.000010         call self._checkToCloseTree(0)
    2              0.000002     endif

FUNCTION  165()
Called 3 times
Total time:   0.000473
 Self time:   0.000141

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    3              0.000007     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    3              0.000008     let oldwinnr = winnr()
    3   0.000223   0.000022     call nerdtree#exec(a:winnumber . "wincmd p")
    3              0.000023     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    3              0.000006     let modified = &modified
    3   0.000099   0.000020     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    3              0.000005     if specialWindow
                                    return 0
                                endif
                            
    3              0.000003     if &hidden
                                    return 1
                                endif
                            
    3   0.000070   0.000018     return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  166()
Called 2 times
Total time:   0.000105
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000025     let newObj = copy(self)
                            
    2              0.000004     let newObj._path = a:path
    2   0.000015   0.000008     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                            
    2              0.000003     if has_key(a:opts, 'reuse')
    2              0.000004         let newObj._reuse = a:opts['reuse']
    2              0.000002     else
                                    let newObj._reuse = ''
                                endif
                            
    2   0.000013   0.000008     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    2              0.000006     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    2              0.000004     let newObj._treetype = b:NERDTreeType
    2   0.000016   0.000006     call newObj._saveCursorPos()
                            
    2              0.000002     return newObj

FUNCTION  167()
Called 1 time
Total time:   0.008916
 Self time:   0.000850

count  total (s)   self (s)
                                " Save the user's settings for splitbelow and splitright
    1              0.000002     let savesplitbelow=&splitbelow
    1              0.000002     let savesplitright=&splitright
                            
                                " 'there' will be set to a command to move from the split window
                                " back to the explorer window
                                "
                                " 'back' will be set to a command to move from the explorer window
                                " back to the newly split window
                                "
                                " 'right' and 'below' will be set to the settings needed for
                                " splitbelow and splitright IF the explorer is the only window.
                                "
    1              0.000003     let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
    1              0.000002     let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
    1              0.000002     let right= g:NERDTreeWinPos ==# "left"
    1              0.000001     let below=0
                            
                                " Attempt to go to adjacent window
    1   0.000028   0.000003     call nerdtree#exec(back)
                            
    1              0.000002     let onlyOneWin = (winnr("$") ==# 1)
                            
                                " If no adjacent window, set splitright and splitbelow appropriately
    1              0.000001     if onlyOneWin
                                    let &splitright=right
                                    let &splitbelow=below
                                else
                                    " found adjacent window - invert split direction
    1              0.000004         let &splitright=!right
    1              0.000002         let &splitbelow=!below
    1              0.000001     endif
                            
    1              0.000002     let splitMode = onlyOneWin ? "vertical" : ""
                            
                                " Open the new window
    1              0.000001     try
    1   0.008826   0.000785         exec(splitMode." sp ")
    1              0.000001     catch /^Vim\%((\a\+)\)\=:E37/
                                    call g:NERDTree.CursorToTreeWin()
                                    throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                catch /^Vim\%((\a\+)\)\=:/
                                    "do nothing
                                endtry
                            
                                "resize the tree window if no other window was open before
    1              0.000001     if onlyOneWin
                                    let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
                                    call nerdtree#exec(there)
                                    exec("silent ". splitMode ." resize ". size)
                                    call nerdtree#exec('wincmd p')
                                endif
                            
                                " Restore splitmode settings
    1              0.000004     let &splitbelow=savesplitbelow
    1              0.000002     let &splitright=savesplitright

FUNCTION  169()
Called 2 times
Total time:   0.183264
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000002     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
    2   0.183253   0.000012         call self._openFile()
    2              0.000002     endif

FUNCTION  airline#highlighter#add_separator()
Called 171 times
Total time:   0.053248
 Self time:   0.002455

count  total (s)   self (s)
  171              0.001067   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  171   0.052111   0.001318   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>78_create()
Called 4 times
Total time:   0.000698
 Self time:   0.000600

count  total (s)   self (s)
    4              0.000007   let _ = ''
    8              0.000027   for idx in range(len(a:parts))
    4   0.000049   0.000027     let part = airline#parts#get(a:parts[idx])
    4              0.000007     let val = ''
                            
    4              0.000012     if exists('part.function')
    4              0.000012       let func = (part.function).'()'
    4              0.000007     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let val = s:spc.g:airline_right_alt_sep.s:spc.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
    4              0.000015     let minwidth = get(part, 'minwidth', 0)
                            
    4              0.000009     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                else
    4              0.000024       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    4              0.000004     endif
                            
    4              0.000010     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
    4   0.000105   0.000029     let val .= s:wrap_accent(part, partval)
    4              0.000011     let _ .= val
    4              0.000003   endfor
    4              0.000006   return _

FUNCTION  89()
Called 3 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    3              0.000009     let line = getline(".")
    3              0.000021     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    3              0.000006     if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
    3              0.000002     return {}

FUNCTION  gitgutter#utility#set_buffer()
Called 28 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
   28              0.000085   let s:bufnr = a:bufnr
   28              0.000240   let s:file = resolve(bufname(a:bufnr))

FUNCTION  airline#util#wrap()
Called 3007 times
Total time:   0.016879
 Self time:   0.016879

count  total (s)   self (s)
 3007              0.006800   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 3007              0.003434   return a:text

FUNCTION  170()
Called 2 times
Total time:   0.183241
 Self time:   0.000059

count  total (s)   self (s)
    2   0.000693   0.000006     if self._reuseWindow()
                                    return
                                endif
                            
    2   0.009643   0.000008     call self._gotoTargetWin()
                            
    2              0.000003     if self._treetype ==# "secondary"
                                    call self._path.edit()
                                else
    2   0.172875   0.000015         call self._path.edit()
                            
                            
    2              0.000004         if self._stay
                                        call self._restoreCursorPos()
                                    endif
    2              0.000002     endif

FUNCTION  172()
Called 2 times
Total time:   0.009521
 Self time:   0.000074

count  total (s)   self (s)
    2   0.000450   0.000021     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
    1   0.008921   0.000005         call self._newSplit()
    1              0.000001     else
    1              0.000002         try
    1   0.000090   0.000007             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
    1   0.000022   0.000003                 call nerdtree#exec('wincmd p')
    1              0.000001             endif
    1              0.000002         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    1              0.000001     endif

FUNCTION  174()
Called 2 times
Total time:   0.000687
 Self time:   0.000275

count  total (s)   self (s)
    2              0.000003     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    2   0.000370   0.000211     let winnr = bufwinnr('^' . self._path.str() . '$')
    2              0.000004     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    2              0.000004     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    2   0.000264   0.000011     let tabnr = self._path.tabnr()
    2              0.000002     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    2              0.000001     return 0

FUNCTION  175()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000005     let self._bufnr = bufnr("")
    2              0.000004     let self._tabnr = tabpagenr()

FUNCTION  <SNR>49__skip_file()
Called 4 times
Total time:   0.000287
 Self time:   0.000155

count  total (s)   self (s)
    4              0.000013     let fname = expand('%', 1)
    4   0.000251   0.000119     let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    4              0.000004     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    4              0.000004     return skip

FUNCTION  gitgutter#diff#process_modified_and_removed()
Called 15 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
   15              0.000025   let offset = 0
   30              0.000054   while offset < a:to_count
   15              0.000043     let line_number = a:to_line + offset
   15              0.000095     call add(a:modifications, [line_number, 'modified'])
   15              0.000028     let offset += 1
   15              0.000015   endwhile
   15              0.000089   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>75_is_branch_empty()
Called 261 times
Total time:   0.001514
 Self time:   0.001514

count  total (s)   self (s)
  261              0.001377   return exists('*airline#extensions#branch#head') && empty(airline#extensions#branch#head())

FUNCTION  <SNR>83_should_change_group()
Called 142 times
Total time:   0.031054
 Self time:   0.003228

count  total (s)   self (s)
  142              0.000292   if a:group1 == a:group2
                                return 0
                              endif
  142   0.015441   0.000729   let color1 = airline#highlighter#get_highlight(a:group1)
  142   0.013818   0.000704   let color2 = airline#highlighter#get_highlight(a:group2)
  142              0.000497   if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
  142              0.000550     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  syntastic#log#debugShowVariables()
Called 4 times
Total time:   0.000027
 Self time:   0.000019

count  total (s)   self (s)
    4   0.000023   0.000015     if !s:_isDebugEnabled(a:level)
    4              0.000000         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>84_build_sections()
Called 63 times
Total time:   0.015153
 Self time:   0.003362

count  total (s)   self (s)
  281              0.000471   for key in a:keys
  218              0.000478     if key == 'warning' && !a:context.active
   13              0.000020       continue
                                endif
  205   0.012902   0.001111     call s:add_section(a:builder, a:context, key)
  205              0.000215   endfor

FUNCTION  <SNR>51_on_window_changed()
Called 17 times
Total time:   0.162624
 Self time:   0.000528

count  total (s)   self (s)
   17              0.000145   if pumvisible()
                                return
                              endif
   17   0.000274   0.000142   call s:init()
   17   0.162072   0.000108   call airline#update_statusline()

FUNCTION  <SNR>49__ignore_file()
Called 4 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    4              0.000031     let fname = fnamemodify(a:filename, ':p')
    4              0.000011     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    4              0.000004     return 0

FUNCTION  airline#extensions#apply_left_override()
Called 4 times
Total time:   0.000802
 Self time:   0.000077

count  total (s)   self (s)
    4              0.000015   let w:airline_section_a = a:section1
    4              0.000010   let w:airline_section_b = a:section2
    4   0.000754   0.000029   let w:airline_section_c = airline#section#create(['readonly'])
    4              0.000010   let w:airline_render_left = 1
    4              0.000009   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
Called 358 times
Total time:   0.001632
 Self time:   0.001632

count  total (s)   self (s)
  358              0.001475     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  gitgutter#highlight#define_sign_column_highlight()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002   if g:gitgutter_override_sign_column_highlight
    1              0.000008     highlight! link SignColumn LineNr
    1              0.000001   else
                                highlight default link SignColumn LineNr
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 18 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
   18              0.000029   return s:hunks

FUNCTION  syntastic#util#setWids()
Called 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000012     for tab in range(1, tabpagenr('$'))
    4              0.000011         for win in range(1, tabpagewinnr(tab, '$'))
    3              0.000013             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    3              0.000023                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    3              0.000009                 let s:_wid_pool += 1
    3              0.000004             endif
    3              0.000003         endfor
    1              0.000001     endfor

FUNCTION  airline#themes#patch()
Called 1 time
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
   13              0.000012   for mode in keys(a:palette)
   12              0.000027     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
   12              0.000007   endfor
                            
    1              0.000004   let a:palette.accents = get(a:palette, 'accents', {})
    1              0.000005   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    1              0.000003   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    1              0.000002   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    1              0.000001   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    1              0.000002   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    1              0.000001   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    1              0.000002   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    1              0.000002   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  gitgutter#utility#strip_trailing_new_line()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000018   return substitute(a:line, '\n$', '', '')

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 195 times
Total time:   0.000446
 Self time:   0.000446

count  total (s)   self (s)
  195              0.000403   let s:summary[1] += a:count

FUNCTION  gitgutter#diff#process_modified_and_added()
Called 60 times
Total time:   0.002696
 Self time:   0.002696

count  total (s)   self (s)
   60              0.000077   let offset = 0
  135              0.000170   while offset < a:from_count
   75              0.000162     let line_number = a:to_line + offset
   75              0.000191     call add(a:modifications, [line_number, 'modified'])
   75              0.000091     let offset += 1
   75              0.000048   endwhile
  255              0.000286   while offset < a:to_count
  195              0.000316     let line_number = a:to_line + offset
  195              0.000432     call add(a:modifications, [line_number, 'added'])
  195              0.000200     let offset += 1
  195              0.000108   endwhile

FUNCTION  airline#highlighter#load_theme()
Called 1 time
Total time:   0.224154
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000009   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    1   0.000069   0.000006     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    1              0.000001   endfor
    1   0.004063   0.000006   call airline#highlighter#highlight(['inactive'])
    1   0.220007   0.000011   call airline#highlighter#highlight(['normal'])

FUNCTION  syntastic#util#compareLexi()
Called 16 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
   24              0.000100     for idx in range(max([len(a:a), len(a:b)]))
   24              0.000080         let a_element = str2nr(get(a:a, idx, 0))
   24              0.000064         let b_element = str2nr(get(a:b, idx, 0))
   24              0.000033         if a_element != b_element
   16              0.000025             return a_element > b_element ? 1 : -1
                                    endif
    8              0.000005     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  nerdtree#runningWindows()
Called 865 times
Total time:   0.005228
 Self time:   0.005228

count  total (s)   self (s)
  865              0.005014     return has("win16") || has("win32") || has("win64")

FUNCTION  gitgutter#all()
Called 6 times
Total time:   0.734434
 Self time:   0.001017

count  total (s)   self (s)
   24              0.000111   for buffer_id in tabpagebuflist()
   18              0.000453     let file = expand('#' . buffer_id . ':p')
   18              0.000065     if !empty(file)
   18   0.733692   0.000275       call gitgutter#process_buffer(buffer_id, 0)
   18              0.000018     endif
   18              0.000015   endfor

FUNCTION  gitgutter#utility#extension()
Called 6 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    6              0.000023   return fnamemodify(s:file, ':e')

FUNCTION  airline#highlighter#highlight()
Called 39 times
Total time:   0.735447
 Self time:   0.149151

count  total (s)   self (s)
   39              0.000136   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   39              0.000368   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   39              0.000106   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   98              0.000166   for mode in mapped
   59              0.000292     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   55              0.000196       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  787              0.001414       for kvp in items(dict)
  732              0.001543         let mode_colors = kvp[1]
  732   0.025441   0.003635         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
 2196              0.003594         for accent in keys(s:accents)
 1464              0.002946           if !has_key(p.accents, accent)
                                        continue
                                      endif
 1464              0.004101           let colors = copy(mode_colors)
 1464              0.002923           if p.accents[accent][0] != ''
  732              0.001809             let colors[0] = p.accents[accent][0]
  732              0.000491           endif
 1464              0.002316           if p.accents[accent][2] != ''
  732              0.001541             let colors[2] = p.accents[accent][2]
  732              0.000452           endif
 1464              0.002003           if len(colors) >= 5
  500              0.001324             let colors[4] = get(p.accents[accent], 4, '')
  500              0.000328           else
  964              0.003127             call add(colors, get(p.accents[accent], 4, ''))
  964              0.000624           endif
 1464   0.052408   0.007753           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
 1464              0.071270         endfor
  732              0.000576       endfor
                            
                                  " TODO: optimize this
  529              0.000951       for sep in items(s:separators)
  474   0.524243   0.004408         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  474              0.000540       endfor
   55              0.000044     endif
   59              0.000043   endfor

FUNCTION  gitgutter#diff#process_added()
Called 90 times
Total time:   0.004209
 Self time:   0.004209

count  total (s)   self (s)
   90              0.000120   let offset = 0
  600              0.000700   while offset < a:to_count
  510              0.000831     let line_number = a:to_line + offset
  510              0.001128     call add(a:modifications, [line_number, 'added'])
  510              0.000552     let offset += 1
  510              0.000337   endwhile

FUNCTION  airline#parts#ffenc()
Called 274 times
Total time:   0.003759
 Self time:   0.003759

count  total (s)   self (s)
  274              0.003644   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 18 times
Total time:   0.022699
 Self time:   0.018944

count  total (s)   self (s)
   18   0.000085   0.000061   let bufnr = gitgutter#utility#bufnr()
   18              0.000066   let other_signs         = getbufvar(bufnr, 'gitgutter_other_signs')
   18              0.000059   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
                            
  963              0.000763   for line in a:modified_lines
  945              0.001369     let line_number = line[0]  " <number>
  945              0.001458     if index(other_signs, line_number) == -1  " don't clobber others' signs
  945   0.006808   0.003077       let name = gitgutter#utility#highlight_name_for_change(line[1])
  945              0.001766       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = gitgutter#sign#next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
                                  else  " update if sign has changed
  945              0.001779         let old_sign = old_gitgutter_signs[line_number]
  945              0.001079         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
  945              0.000546       endif
  945              0.000545     endif
  945              0.000535   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>84_get_section()
Called 265 times
Total time:   0.009056
 Self time:   0.008090

count  total (s)   self (s)
  265              0.000864   if has_key(s:section_truncate_width, a:key)
  121              0.000442     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   30              0.000050       return ''
                                endif
   91              0.000066   endif
  235              0.000585   let spc = g:airline_symbols.space
  235   0.002924   0.001958   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  235              0.001757   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  235              0.001029   return empty(text) ? '' : prefix.text.suffix

FUNCTION  nerdtree#compareNodesBySortKey()
Called 8 times
Total time:   0.001291
 Self time:   0.000124

count  total (s)   self (s)
    8   0.000990   0.000060     if a:n1.path.getSortKey() < a:n2.path.getSortKey()
    3              0.000004         return -1
                                elseif a:n1.path.getSortKey() > a:n2.path.getSortKey()
    5              0.000007         return 1
                                else
                                    return 0
                                endif

FUNCTION  gitgutter#diff#parse_hunk()
Called 286 times
Total time:   0.011041
 Self time:   0.011041

count  total (s)   self (s)
  286              0.004495   let matches = matchlist(a:line, s:hunk_re)
  286              0.000640   if len(matches) > 0
  285              0.000984     let from_line  = str2nr(matches[1])
  285              0.001228     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
  285              0.000796     let to_line    = str2nr(matches[3])
  285              0.001483     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
  285              0.000957     return [from_line, from_count, to_line, to_count]
                              else
    1              0.000001     return []
                              end

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000016   return getbufvar(s:bufnr, 'changedtick') != getbufvar(s:bufnr, 'gitgutter_last_tick')

FUNCTION  airline#parts#get()
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000021   return get(s:parts, a:key, {})

FUNCTION  airline#load_theme()
Called 1 time
Total time:   0.230213
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000006   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    1              0.000004   let palette = g:airline#themes#{g:airline_theme}#palette
    1   0.000119   0.000005   call airline#themes#patch(palette)
                            
    1              0.000002   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    1   0.224163   0.000009   call airline#highlighter#load_theme()
    1   0.000047   0.000018   call airline#extensions#load_theme()
    1   0.005863   0.000006   call airline#update_statusline()

FUNCTION  airline#parts#paste()
Called 473 times
Total time:   0.001401
 Self time:   0.001401

count  total (s)   self (s)
  473              0.001211   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 18 times
Total time:   0.167821
 Self time:   0.003062

count  total (s)   self (s)
   47              0.000439   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
   29   0.000505   0.000262     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
   29              0.000185     call setwinvar(nr, 'airline_active', 0)
   29              0.000257     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   29   0.086264   0.000361     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   29              0.000043   endfor
                            
   18              0.000040   unlet! w:airline_render_left
   18              0.000023   unlet! w:airline_render_right
  162              0.000183   for section in s:sections
  144              0.000303     unlet! w:airline_section_{section}
  144              0.000103   endfor
                            
   18              0.000040   let w:airline_active = 1
   18              0.000104   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   18   0.078810   0.000197   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#sign#update_signs()
Called 18 times
Total time:   0.079278
 Self time:   0.001722

count  total (s)   self (s)
   18   0.045776   0.000109   call gitgutter#sign#find_current_signs()
                            
   18              0.000737   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
   18   0.008948   0.000239   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
   18              0.000064   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
   18              0.000022   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
   18   0.000614   0.000133   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
   18   0.022903   0.000204   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
   18              0.000021   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  SyntasticLoclistHide()
Called 1 time
Total time:   0.000023
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000018   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    1              0.000003     silent! lclose

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 18 times
Total time:   0.008709
 Self time:   0.008668

count  total (s)   self (s)
   18   0.000119   0.000078   let bufnr = gitgutter#utility#bufnr()
   18              0.000034   let signs_to_remove = []  " list of [<id (number)>, ...]
   18              0.000035   let remove_all_signs = 1
   18              0.000079   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
  963              0.001039   for line_number in keys(old_gitgutter_signs)
  945              0.002571     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
  945              0.001082       let remove_all_signs = 0
  945              0.000523     endif
  945              0.000544   endfor
   18              0.000064   let s:remove_all_old_signs = remove_all_signs
   18              0.000031   return signs_to_remove

FUNCTION  airline#parts#readonly()
Called 551 times
Total time:   0.001665
 Self time:   0.001665

count  total (s)   self (s)
  551              0.001371   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  nerdtree#has_opt()
Called 291 times
Total time:   0.000835
 Self time:   0.000835

count  total (s)   self (s)
  291              0.000759     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#highlighter#exec()
Called 2879 times
Total time:   0.090166
 Self time:   0.090166

count  total (s)   self (s)
 2879              0.004858   let colors = a:colors
 2879              0.003063   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 2879              0.063657   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  <SNR>72_sync_active_winnr()
Called 102 times
Total time:   0.001221
 Self time:   0.001221

count  total (s)   self (s)
  102              0.000745   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 473 times
Total time:   0.130867
 Self time:   0.122153

count  total (s)   self (s)
  473              0.002285   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
  473              0.001468   if !exists('b:airline_whitespace_check')
    4              0.000008     let b:airline_whitespace_check = ''
    4              0.000016     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    4              0.000006     let trailing = 0
    4              0.000008     if index(checks, 'trailing') > -1
    4              0.101509       let trailing = search('\s$', 'nw')
    4              0.000028     endif
                            
    4              0.000019     let mixed = 0
    4              0.000033     if index(checks, 'indent') > -1
    4   0.008804   0.000090       let mixed = s:check_mixed_indent()
    4              0.000030     endif
                            
    4              0.000025     if trailing != 0 || mixed != 0
    3              0.000020       let b:airline_whitespace_check = s:symbol
    3              0.000003       if s:show_message
    3              0.000004         if trailing != 0
    3              0.000079           let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
    3              0.000004         endif
    3              0.000004         if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
    3              0.000002       endif
    3              0.000002     endif
    4              0.000003   endif
  473              0.000805   return b:airline_whitespace_check

FUNCTION  gitgutter#diff#process_modified()
Called 120 times
Total time:   0.002151
 Self time:   0.002151

count  total (s)   self (s)
  120              0.000156   let offset = 0
  270              0.000368   while offset < a:to_count
  150              0.000289     let line_number = a:to_line + offset
  150              0.000412     call add(a:modifications, [line_number, 'modified'])
  150              0.000177     let offset += 1
  150              0.000110   endwhile

FUNCTION  gitgutter#diff#is_modified_and_added()
Called 75 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   75              0.000170   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  nerdtree#exec()
Called 8 times
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
    8              0.000039     let old_ei = &ei
    8              0.000041     set ei=all
    8              0.000188     exec a:cmd
    8              0.000044     let &ei = old_ei

FUNCTION  gitgutter#diff#is_modified_and_removed()
Called 15 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   15              0.000037   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  <SNR>84_add_section()
Called 205 times
Total time:   0.011791
 Self time:   0.004119

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  205              0.000358     if a:key == 'warning'
   16   0.000106   0.000050       call a:builder.add_raw('%(')
   16              0.000015     endif
  205   0.009432   0.001863     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  205              0.000346     if a:key == 'warning'
   16   0.000093   0.000046       call a:builder.add_raw('%)')
   16              0.000011     endif

FUNCTION  gitgutter#utility#not_git_dir()
Called 20 times
Total time:   0.000549
 Self time:   0.000317

count  total (s)   self (s)
   20   0.000545   0.000313   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 20 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   20              0.000212   return fnamemodify(s:file, ':p:h')

FUNCTION  <SNR>51_init()
Called 18 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
   18              0.000067   if s:airline_initialized
   18              0.000031     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:airline_theme_defined = exists('g:airline_theme')
                              if s:airline_theme_defined || !airline#switch_matching_theme()
                                let g:airline_theme = get(g:, 'airline_theme', 'dark')
                                call airline#switch_theme(g:airline_theme)
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  gitgutter#diff#process_hunk()
Called 285 times
Total time:   0.027362
 Self time:   0.015347

count  total (s)   self (s)
  285              0.000483   let modifications = []
  285              0.000546   let from_line  = a:hunk[0]
  285              0.000489   let from_count = a:hunk[1]
  285              0.000438   let to_line    = a:hunk[2]
  285              0.000487   let to_count   = a:hunk[3]
                            
  285   0.001383   0.000834   if gitgutter#diff#is_added(from_count, to_count)
   90   0.004575   0.000366     call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
   90   0.000891   0.000679     call gitgutter#hunk#increment_lines_added(to_count)
                            
   90              0.000169   elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
  120   0.002659   0.000508     call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
  120   0.000891   0.000604     call gitgutter#hunk#increment_lines_modified(to_count)
                            
  120              0.000225   elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
   60   0.002957   0.000261     call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
   60   0.000350   0.000219     call gitgutter#hunk#increment_lines_added(to_count - from_count)
   60   0.000282   0.000171     call gitgutter#hunk#increment_lines_modified(from_count)
                            
   60              0.000112   elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
   15   0.000571   0.000102     call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
   15   0.000114   0.000066     call gitgutter#hunk#increment_lines_modified(to_count)
   15   0.000096   0.000062     call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
   15              0.000009   endif
  285              0.000301   return modifications

FUNCTION  airline#switch_matching_theme()
Called 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    1              0.000003   if exists('g:colors_name')
    1              0.000002     try
    1              0.000029       let palette = g:airline#themes#{g:colors_name}#palette
                                  call airline#switch_theme(g:colors_name)
                                  return 1
                                catch
    7              0.000013       for map in items(g:airline_theme_map)
    6              0.000031         if match(g:colors_name, map[0]) > -1
                                      call airline#switch_theme(map[1])
                                      return 1
                                    endif
    6              0.000005       endfor
    1              0.000002     endtry
    1              0.000001   endif
    1              0.000001   return 0

FUNCTION  <SNR>79_exec_separator()
Called 645 times
Total time:   0.570628
 Self time:   0.213112

count  total (s)   self (s)
  645   0.064354   0.003201   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  645   0.361242   0.086917   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  645              0.001957   let group = a:from.'_to_'.a:to.a:suffix
  645              0.000730   if a:inverse
  178              0.000929     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  178              0.000157   else
  467              0.002172     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  467              0.000349   endif
  645              0.001891   let a:dict[group] = colors
  645   0.134028   0.111990   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>83_get_seperator()
Called 142 times
Total time:   0.080275
 Self time:   0.001860

count  total (s)   self (s)
  142   0.031848   0.000794   if s:should_change_group(a:prev_group, a:group)
  142   0.048348   0.000987     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#highlighter#add_accent()
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000017   let s:accents[a:accent] = 1

FUNCTION  gitgutter#hunk#summary()
Called 261 times
Total time:   0.000541
 Self time:   0.000541

count  total (s)   self (s)
  261              0.000420   return s:summary

FUNCTION  gitgutter#utility#shell_error()
Called 20 times
Total time:   0.000801
 Self time:   0.000254

count  total (s)   self (s)
   20   0.000753   0.000206   return gitgutter#utility#using_xolox_shell() ? s:exit_code : v:shell_error

FUNCTION  200()
Called 14 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   14              0.000083     let newObj = copy(self)
   14              0.000034     let newObj._flags = {}
   14              0.000019     return newObj

FUNCTION  202()
Called 5 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    5              0.000009     let flagstring = ""
    5              0.000013     for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
    5              0.000008     if len(flagstring) == 0
    5              0.000005         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  205()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000004     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  208()
Called 7 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    7              0.000041     return exists("b:NERDTreeRoot")

FUNCTION  <SNR>49_QuitPreHook()
Called 1 time
Total time:   0.000298
 Self time:   0.000140

count  total (s)   self (s)
    1              0.000059     let buf = bufnr(fnameescape(a:fname))
    1   0.000045   0.000026     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000024   0.000007     if !syntastic#util#var('check_on_wq')
    1   0.000111   0.000012         call syntastic#util#setWids()
    1              0.000012         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000001     endif
                            
    1              0.000005     if get(w:, 'syntastic_loclist_set', 0)
    1   0.000033   0.000010         call SyntasticLoclistHide()
    1              0.000001     endif

FUNCTION  gitgutter#utility#bufnr()
Called 92 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
   92              0.000125   return s:bufnr

FUNCTION  <SNR>78_wrap_accent()
Called 4 times
Total time:   0.000076
 Self time:   0.000058

count  total (s)   self (s)
    4              0.000013   if exists('a:part.accent')
    4   0.000042   0.000024     call airline#highlighter#add_accent(a:part.accent)
    4              0.000019     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  <SNR>75_get_hunks_gitgutter()
Called 261 times
Total time:   0.005764
 Self time:   0.002828

count  total (s)   self (s)
  261   0.003007   0.001493   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  261   0.002139   0.000717   return GitGutterGetHunkSummary()

FUNCTION  airline#parts#crypt()
Called 473 times
Total time:   0.002677
 Self time:   0.002677

count  total (s)   self (s)
  473              0.002407   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  215()
Called 20 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
   20              0.000065     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
   20              0.000038     return s:NERDTree._PathFilters

FUNCTION  216()
Called 1 time
Total time:   0.006096
 Self time:   0.000009

count  total (s)   self (s)
    1   0.006095   0.000008     call self.ui.render()

FUNCTION  218()
Called 1 time
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
    1              0.000006     let old_h = @h
    1              0.000003     if b:treeShowHelp ==# 1
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (b:NERDTreeShowHidden ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (b:NERDTreeIgnoreEnabled ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (b:NERDTreeShowFiles ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (b:NERDTreeShowBookmarks ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark [<name>]\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif g:NERDTreeMinimalUI == 0
    1              0.000008         let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
    1              0.000008         silent! put h
    1              0.000001     endif
                            
    1              0.000003     let @h = old_h

FUNCTION  syntastic#log#debugDump()
Called 2 times
Total time:   0.000010
 Self time:   0.000006

count  total (s)   self (s)
    2   0.000008   0.000004     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  airline#extensions#load_theme()
Called 1 time
Total time:   0.000029
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000028   0.000018   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  <SNR>77_check_mixed_indent()
Called 4 times
Total time:   0.008714
 Self time:   0.008714

count  total (s)   self (s)
    4              0.000010   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    4              0.008635     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  gitgutter#diff#run_diff()
Called 20 times
Total time:   1.096176
 Self time:   0.004023

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
   20              0.000046   let cmd = '('
                            
   20   0.000103   0.000069   let bufnr = gitgutter#utility#bufnr()
   20              0.000069   let tracked = getbufvar(bufnr, 'gitgutter_tracked')  " i.e. tracked by git
   20              0.000024   if !tracked
    3   0.000073   0.000025     let cmd .= 'git ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
    3              0.000003   endif
                            
   20              0.000023   if a:realtime
    6   0.052639   0.000066     let blob_name = ':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
    6              0.000028     let blob_file = tempname()
    6              0.000015     let buff_file = tempname()
    6   0.000055   0.000024     let extension = gitgutter#utility#extension()
    6              0.000012     if !empty(extension)
    6              0.000017       let blob_file .= '.'.extension
    6              0.000012       let buff_file .= '.'.extension
    6              0.000005     endif
    6              0.000024     let cmd .= 'git show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
    6              0.000044     let modified      = getbufvar(bufnr, "&mod")
    6              0.000028     let op_mark_start = getpos("'[")
    6              0.000016     let op_mark_end   = getpos("']")
                            
    6              0.000927     execute 'keepalt silent write' buff_file
                            
    6              0.000070     call setbufvar(bufnr, "&mod", modified)
    6              0.000023     call setpos("'[", op_mark_start)
    6              0.000011     call setpos("']", op_mark_end)
    6              0.000005   endif
                            
   20              0.000088   let cmd .= 'git diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '
   20              0.000022   if a:realtime
    6              0.000019     let cmd .= blob_file.' '.buff_file
    6              0.000004   else
   14   0.000264   0.000083     let cmd .= gitgutter#utility#shellescape(gitgutter#utility#filename())
   14              0.000013   endif
                            
   20              0.000043   if a:use_external_grep && s:grep_available
   20              0.000046     let cmd .= s:grep_command
   20              0.000009   endif
                            
   20              0.000042   if (a:use_external_grep && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
   20              0.000050     let cmd.= ' || exit 0'
   20              0.000010   endif
                            
   20              0.000033   let cmd .= ')'
                            
   20              0.000030   if !tracked
    3              0.000003     let cmd .= ')'
    3              0.000003   endif
                            
   20   1.038854   0.000369   let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd))
                            
   20              0.000057   if a:realtime
    6              0.000092     call delete(blob_file)
    6              0.000051     call delete(buff_file)
    6              0.000007   endif
                            
   20   0.001038   0.000237   if gitgutter#utility#shell_error()
                                " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
    2              0.761872     throw 'diff failed'
                              endif
                            
   18              0.000027   if !tracked
    1              0.000012     call setbufvar(bufnr, 'gitgutter_tracked', 1)
    1              0.000001   endif
                            
   18              0.000052   return diff

FUNCTION  220()
Called 9 times
Total time:   0.009943
 Self time:   0.002127

count  total (s)   self (s)
    9              0.000045     let line = getline(a:ln)
                            
    9   0.000483   0.000049     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
    9              0.000015     if a:ln == rootLine
                                    return b:NERDTreeRoot.path
                                endif
                            
    9              0.000018     if !g:NERDTreeDirArrows
                                    " in case called from outside the tree
                                    if line !~# '^ *[|`▸▾ ]' || line =~# '^$'
                                        return {}
                                    endif
                                endif
                            
    9   0.000065   0.000047     if line ==# s:UI.UpDirLine()
                                    return b:NERDTreeRoot.path.getParent()
                                endif
                            
    9   0.000276   0.000040     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
    9   0.000664   0.000052     let curFile = self._stripMarkup(line, 0)
                            
    9              0.000014     let wasdir = 0
    9              0.000028     if curFile =~# '/$'
    3              0.000005         let wasdir = 1
    3              0.000021         let curFile = substitute(curFile, '/\?$', '/', "")
    3              0.000003     endif
                            
    9              0.000012     let dir = ""
    9              0.000014     let lnum = a:ln
   48              0.000055     while lnum > 0
   48              0.000085         let lnum = lnum - 1
   48              0.000110         let curLine = getline(lnum)
   48   0.002939   0.000198         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
   48              0.000060         if lnum == rootLine
    9   0.000745   0.000081             let dir = b:NERDTreeRoot.path.str({'format': 'UI'}) . dir
    9              0.000010             break
                                    endif
   39              0.000128         if curLineStripped =~# '/$'
   27   0.000581   0.000106             let lpindent = self._indentLevelFor(curLine)
   27              0.000033             if lpindent < indent
    3              0.000004                 let indent = indent - 1
                            
    3              0.000013                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
    3              0.000004                 continue
                                        endif
   24              0.000017         endif
   36              0.000033     endwhile
    9              0.000034     let curFile = b:NERDTreeRoot.path.drive . dir . curFile
    9   0.002691   0.000055     let toReturn = g:NERDTreePath.New(curFile)
    9              0.000010     return toReturn

FUNCTION  221()
Called 1 time
Total time:   0.000629
 Self time:   0.000130

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
    1   0.000195   0.000003     if a:file_node.isRoot()
                                    return b:NERDTree.ui.getRootLineNum()
                                endif
                            
    1              0.000003     let totalLines = line("$")
                            
                                "the path components we have matched so far
    1   0.000076   0.000019     let pathcomponents = [substitute(b:NERDTreeRoot.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
    1              0.000002     let curPathComponent = 1
                            
    1   0.000059   0.000006     let fullpath = a:file_node.path.str({'format': 'UI'})
                            
    1   0.000036   0.000004     let lnum = b:NERDTree.ui.getRootLineNum()
    2              0.000003     while lnum > 0
    2              0.000003         let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
    2              0.000004         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
    2              0.000004         let curLine = getline(lnum)
                            
    2   0.000050   0.000009         let indent = self._indentLevelFor(curLine)
    2              0.000003         if indent ==# curPathComponent
    2   0.000132   0.000008             let curLine = self._stripMarkup(curLine, 1)
                            
    2              0.000008             let curPath =  join(pathcomponents, '/') . '/' . curLine
    2              0.000005             if stridx(fullpath, curPath, 0) ==# 0
    1              0.000003                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
    1              0.000005                     let curLine = substitute(curLine, '/ *$', '', '')
    1              0.000003                     call add(pathcomponents, curLine)
    1              0.000003                     let curPathComponent = curPathComponent + 1
                            
    1              0.000002                     if fullpath ==# curPath
    1              0.000001                         return lnum
                                                endif
                                            endif
                                        endif
    1              0.000001         endif
    1              0.000001     endwhile
                                return -1

FUNCTION  222()
Called 10 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
   10              0.000021     let rootLine = 1
   40              0.000265     while getline(rootLine) !~# '^\(/\|<\)'
   30              0.000089         let rootLine = rootLine + 1
   30              0.000030     endwhile
   10              0.000014     return rootLine

FUNCTION  223()
Called 38 times
Total time:   0.000752
 Self time:   0.000705

count  total (s)   self (s)
   38   0.000388   0.000341     let level = match(a:line, '[^ \-+~▸▾`|]') / s:UI.IndentWid()
                                " check if line includes arrows
   38              0.000168     if match(a:line, '[▸▾]') > -1
                                    " decrement level as arrow uses 3 ascii chars
   32              0.000063         let level = level - 1
   32              0.000024     endif
   38              0.000040     return level

FUNCTION  224()
Called 38 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   38              0.000039     return 2

FUNCTION  225()
Called 60 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
   60              0.000088     if g:NERDTreeDirArrows
   60              0.000098         return '^\([▾▸] \| \+[▾▸] \| \+\)'
                                endif
                            
                                return '^[ `|]*[\-+~]'

FUNCTION  229()
Called 59 times
Total time:   0.003477
 Self time:   0.003270

count  total (s)   self (s)
   59              0.000094     let line = a:line
                                "remove the tree parts and the leading space
   59   0.000757   0.000550     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
   59              0.000262     let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
   59              0.000220     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
   59              0.000223     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
   59              0.000204     let line = substitute (line, '\[[^]]*\]', "","")
                            
   59              0.000081     let wasdir = 0
   59              0.000169     if line =~# '/$'
   41              0.000049         let wasdir = 1
   41              0.000031     endif
   59              0.000233     let line = substitute (line,' -> .*',"","") " remove link to
   59              0.000064     if wasdir ==# 1
   41              0.000254         let line = substitute (line, '/\?$', '/', "")
   41              0.000034     endif
                            
   59              0.000074     if a:removeLeadingSpaces
   50              0.000202         let line = substitute (line, '^ *', '', '')
   50              0.000034     endif
                            
   59              0.000059     return line

FUNCTION  GitGutterGetHunkSummary()
Called 261 times
Total time:   0.001422
 Self time:   0.000881

count  total (s)   self (s)
  261   0.001328   0.000787   return gitgutter#hunk#summary()

FUNCTION  airline#parts#mode()
Called 473 times
Total time:   0.001873
 Self time:   0.001873

count  total (s)   self (s)
  473              0.001599   return get(w:, 'airline_current_mode', '')

FUNCTION  airline#extensions#quickfix#apply()
Called 18 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   18              0.000042   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 15 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
   15              0.000031   let s:summary[2] += a:count

FUNCTION  230()
Called 1 time
Total time:   0.006087
 Self time:   0.000340

count  total (s)   self (s)
    1              0.000012     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
    1              0.000005     let curLine = line(".")
    1              0.000003     let curCol = col(".")
    1              0.000004     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
    1              0.000117     silent 1,$delete _
                            
    1   0.000258   0.000016     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
    1              0.000002     if g:NERDTreeMinimalUI == 0
    1              0.000010         call setline(line(".")+1, "")
    1              0.000007         call cursor(line(".")+1, col("."))
    1              0.000001     endif
                            
    1              0.000003     if b:NERDTreeShowBookmarks
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
    1              0.000003     if !g:NERDTreeMinimalUI
    1   0.000014   0.000011         call setline(line(".")+1, s:UI.UpDirLine())
    1              0.000005         call cursor(line(".")+1, col("."))
    1              0.000001     endif
                            
                                "draw the header line
    1   0.000155   0.000016     let header = b:NERDTreeRoot.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    1              0.000007     call setline(line(".")+1, header)
    1              0.000006     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
    1              0.000003     let old_o = @o
    1   0.005375   0.000012     let @o = b:NERDTreeRoot.renderToString()
    1              0.000016     silent put o
    1              0.000003     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
    1              0.000007     silent 1,1delete _
                            
                                "restore the view
    1              0.000004     let old_scrolloff=&scrolloff
    1              0.000009     let &scrolloff=0
    1              0.000003     call cursor(topLine, 1)
    1              0.000021     normal! zt
    1              0.000004     call cursor(curLine, curCol)
    1              0.000003     let &scrolloff = old_scrolloff
                            
    1              0.000004     setlocal nomodifiable

FUNCTION  237()
Called 10 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
   10              0.000015     return '.. (up a dir)'

FUNCTION  238()
Called 5 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    5              0.000024     let newObj = copy(self)
    5              0.000017     let newObj.nerdtree = a:nerdtree
    5              0.000015     let newObj.subject = a:subject
    5              0.000016     let newObj.action = a:action
    5              0.000015     let newObj.params = a:params
    5              0.000009     return newObj

FUNCTION  <SNR>49__is_quitting()
Called 4 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    4              0.000004     let quitting = 0
    4              0.000008     if exists('w:syntastic_wid')
    2              0.000011         let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
    2              0.000006         let idx = index(s:_quit_pre, key)
    2              0.000002         if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
    2              0.000001     endif
                            
    4              0.000005     return quitting

FUNCTION  <SNR>79_get_array()
Called 1574 times
Total time:   0.017033
 Self time:   0.017033

count  total (s)   self (s)
 1574              0.002554   let fg = a:fg
 1574              0.002102   let bg = a:bg
 1574              0.011480   return has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 6 times
Total time:   0.052490
 Self time:   0.000227

count  total (s)   self (s)
    6              0.000044   let file_path_relative_to_repo_root = getbufvar(s:bufnr, 'gitgutter_repo_relative_path')
    6              0.000019   if empty(file_path_relative_to_repo_root)
    1   0.052263   0.000028     let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file('git rev-parse --show-prefix'))
    1   0.000050   0.000031     let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
    1   0.000021   0.000012     let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
    1              0.000009     call setbufvar(s:bufnr, 'gitgutter_repo_relative_path', file_path_relative_to_repo_root)
    1              0.000001   endif
    6              0.000012   return file_path_relative_to_repo_root

FUNCTION  240()
Called 5 times
Total time:   0.000344
 Self time:   0.000130

count  total (s)   self (s)
    5   0.000154   0.000054     let event = g:NERDTreeEvent.New(b:NERDTree, a:path, a:event, a:params)
                            
    5   0.000156   0.000042     for listener in s:Notifier.GetListenersForEvent(a:event)
                                    call {listener}(event)
                                endfor

FUNCTION  241()
Called 5 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    5              0.000027     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
    5              0.000010     return s:refreshListenersMap

FUNCTION  242()
Called 5 times
Total time:   0.000114
 Self time:   0.000056

count  total (s)   self (s)
    5   0.000090   0.000032     let listenersMap = s:Notifier.GetListenersMap()
    5              0.000022     return get(listenersMap, a:name, [])

FUNCTION  244()
Called 8 times
Total time:   0.000392
 Self time:   0.000064

count  total (s)   self (s)
    8   0.000083   0.000029     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    8   0.000302   0.000028     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  245()
Called 8 times
Total time:   0.000274
 Self time:   0.000160

count  total (s)   self (s)
    8   0.000072   0.000027     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    8   0.000085   0.000031     let auto_loc_list = syntastic#util#var('auto_loc_list')
    8   0.000034   0.000019     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    8              0.000012         if auto_loc_list == 1 || auto_loc_list == 2
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    8              0.000009             lclose
    8              0.000006         endif
    8              0.000006     endif

FUNCTION  247()
Called 16 times
Total time:   0.000181
 Self time:   0.000068

count  total (s)   self (s)
   16   0.000175   0.000062     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  248()
Called 8 times
Total time:   0.000202
 Self time:   0.000100

count  total (s)   self (s)
    8              0.000013     unlet! b:syntastic_private_balloons
    8   0.000131   0.000029     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  249()
Called 2 times
Total time:   0.000045
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000005     let b:syntastic_private_balloons = {}
    2              0.000004     if has('balloon_eval')
    2   0.000020   0.000006         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    2              0.000004         unlet! b:syntastic_private_balloons
    2              0.000008         set noballooneval
    2              0.000002     endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 150 times
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
  150              0.000306   let s:summary[0] += a:count

FUNCTION  <SNR>9_BMHash()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                              " Make name all upper case, so that chars are between 32 and 96
    1              0.000010   let nm = substitute(a:name, ".*", '\U\0', "")
    1              0.000003   if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
                              else
    1              0.000002     let sp = char2nr(' ')
    1              0.000001   endif
                              " convert first six chars into a number for sorting:
    1              0.000012   return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 18 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   18              0.000139   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>11_LoadFTPlugin()
Called 2 times
Total time:   0.003485
 Self time:   0.001536

count  total (s)   self (s)
    2              0.000016     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000009     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000024       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000017       for name in split(s, '\.')
    2   0.003378   0.001429 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000003       endfor
    2              0.000002     endif

FUNCTION  <SNR>72_is_excluded_window()
Called 47 times
Total time:   0.003006
 Self time:   0.003006

count  total (s)   self (s)
   47              0.000159   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  188              0.000334   for matchw in g:airline_exclude_filenames
  141              0.001131     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  141              0.000141   endfor
                            
   47              0.000102   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   47              0.000054   return 0

FUNCTION  251()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003     return self._filetype

FUNCTION  252()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return self._name

FUNCTION  253()
Called 2 times
Total time:   0.000051
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000033   0.000020     let user_exec = expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
    2              0.000004     if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif

FUNCTION  airline#statusline()
Called 551 times
Total time:   0.010745
 Self time:   0.010745

count  total (s)   self (s)
  551              0.005423   if has_key(s:contexts, a:winnr)
  551              0.004134     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#hunk#reset()
Called 28 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
   28              0.000156   let s:summary = [0, 0, 0]

FUNCTION  gitgutter#utility#exists_file()
Called 28 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   28              0.000229   return filereadable(s:file)

FUNCTION  syntastic#util#unique()
Called 4 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    4              0.000007     let seen = {}
    4              0.000006     let uniques = []
    8              0.000010     for e in a:list
    4              0.000012         let k = string(e)
    4              0.000008         if !has_key(seen, k)
    4              0.000008             let seen[k] = 1
    4              0.000010             call add(uniques, e)
    4              0.000003         endif
    4              0.000004     endfor
    4              0.000005     return uniques

FUNCTION  gitgutter#utility#directory_of_file()
Called 21 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   21              0.000063   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>83_get_accented_line()
Called 218 times
Total time:   0.010674
 Self time:   0.010674

count  total (s)   self (s)
  218              0.000387   if a:self._context.active
  118              0.000202     let contents = []
  118              0.000846     let content_parts = split(a:contents, '__accent')
  276              0.000464     for cpart in content_parts
  158              0.001112       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  158              0.000450       call add(contents, cpart)
  158              0.000157     endfor
  118              0.000410     let line = join(contents, a:group)
  118              0.000773     let line = substitute(line, '__restore__', a:group, 'g')
  118              0.000096   else
  100              0.001373     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  100              0.000768     let line = substitute(line, '%#__restore__#', '', 'g')
  100              0.000105   endif
  218              0.000279   return line

FUNCTION  262()
Called 2 times
Total time:   0.000068
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000056   0.000005     call self.syncExec()
    2              0.000003     if !has_key(self, '_available')
                                    let self._available = self._isAvailableFunc()
                                endif
    2              0.000002     return self._available

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 18 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   18              0.000140   call setbufvar(s:bufnr, 'gitgutter_last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  airline#highlighter#get_highlight()
Called 1574 times
Total time:   0.356101
 Self time:   0.257008

count  total (s)   self (s)
 1574   0.052298   0.009124   let fg = s:get_syn(a:group, 'fg')
 1574   0.260586   0.221700   let bg = s:get_syn(a:group, 'bg')
 1574              0.016088   let reverse = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1574   0.025870   0.008837   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 473 times
Total time:   0.043864
 Self time:   0.005444

count  total (s)   self (s)
  473   0.040606   0.002186   let errors = SyntasticStatuslineFlag()
  473              0.001183   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
  473              0.000427   return ''

FUNCTION  syntastic#util#var()
Called 81 times
Total time:   0.000583
 Self time:   0.000583

count  total (s)   self (s)
   81              0.000559     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  270()
Called 16 times
Total time:   0.000154
 Self time:   0.000050

count  total (s)   self (s)
   16   0.000151   0.000047     return syntastic#util#var('echo_current_error')

FUNCTION  271()
Called 8 times
Total time:   0.000204
 Self time:   0.000116

count  total (s)   self (s)
    8   0.000118   0.000030     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  272()
Called 2 times
Total time:   0.000035
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000019   0.000007     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    2              0.000008     autocmd! syntastic CursorMoved
    2              0.000004     unlet! b:syntastic_private_messages
    2              0.000004     let b:syntastic_private_line = -1

FUNCTION  274()
Called 16 times
Total time:   0.000165
 Self time:   0.000057

count  total (s)   self (s)
   16   0.000162   0.000054     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  275()
Called 8 times
Total time:   0.000548
 Self time:   0.000337

count  total (s)   self (s)
    8   0.000095   0.000018     if self.enabled()
    8   0.000085   0.000029         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    8   0.000083   0.000021         call self._reset()
    8              0.000018         let buf = bufnr('')
    8   0.000054   0.000038         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    8              0.000014         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    8              0.000006     endif

FUNCTION  276()
Called 2 times
Total time:   0.000050
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000002     if s:has_highlighting
    2   0.000019   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    2   0.000025   0.000009         call self._reset()
    2              0.000001     endif

FUNCTION  278()
Called 10 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   10              0.000023     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  279()
Called 3 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    3              0.000034     let newObj = copy(self)
                            
    3              0.000011     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    3              0.000004     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    3              0.000006     let newObj._rawLoclist = llist
    3              0.000003     let newObj._name = ''
    3              0.000006     let newObj._owner = bufnr('')
    3              0.000006     let newObj._sorted = 0
    3              0.000005     let newObj._columns = g:syntastic_cursor_columns
                            
    3              0.000003     return newObj

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 38 times
Total time:   0.002879
 Self time:   0.001212

count  total (s)   self (s)
   38              0.000155   if getbufvar(a:bufnr, '&modified')
   16              0.000184     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   16              0.000015   else
   22              0.000203     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   22              0.000016   endif
                            
   38              0.000069   if !empty(colors)
   38   0.001951   0.000284     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   38              0.000034   endif

FUNCTION  gitgutter#highlight#match_highlight()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000015   let matches = matchlist(a:highlight, a:pattern)
    2              0.000003   if len(matches) == 0
    2              0.000002     return 'NONE'
                              endif
                              return matches[1]

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 41 times
Total time:   0.000880
 Self time:   0.000880

count  total (s)   self (s)
   41              0.000111   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
   41              0.000063   return s:using_xolox_shell

FUNCTION  280()
Called 483 times
Total time:   0.005172
 Self time:   0.005135

count  total (s)   self (s)
  483              0.002425     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
    1   0.000044   0.000007         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    1              0.000001     endif
  483              0.000673     return b:syntastic_loclist

FUNCTION  283()
Called 52 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   52              0.000090     return empty(self._rawLoclist)

FUNCTION  284()
Called 16 times
Total time:   0.000498
 Self time:   0.000154

count  total (s)   self (s)
   16              0.000035     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
   16   0.000410   0.000066     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  285()
Called 8 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    8              0.000015     return copy(self._rawLoclist)

FUNCTION  286()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003     return self._rawLoclist

FUNCTION  287()
Called 4 times
Total time:   0.000141
 Self time:   0.000038

count  total (s)   self (s)
    4   0.000141   0.000038     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  289()
Called 473 times
Total time:   0.029679
 Self time:   0.029679

count  total (s)   self (s)
  473              0.001406     if !exists('self._stl_format')
    2              0.000005         let self._stl_format = ''
    2              0.000001     endif
  473              0.001034     if !exists('self._stl_flag')
    2              0.000004         let self._stl_flag = ''
    2              0.000001     endif
                            
  473              0.001172     if g:syntastic_stl_format !=# self._stl_format
    2              0.000003         let self._stl_format = g:syntastic_stl_format
                            
    2              0.000003         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
    2              0.000002             let self._stl_flag = ''
    2              0.000001         endif
    2              0.000002     endif
                            
  473              0.000676     return self._stl_flag

FUNCTION  <SNR>9_BMFilename()
Called 1 time
Total time:   0.000295
 Self time:   0.000194

count  total (s)   self (s)
    1              0.000003   if isdirectory(a:name)
                                return
                              endif
    1   0.000074   0.000007   let munge = <SID>BMMunge(a:name, a:num)
    1   0.000046   0.000012   let hash = <SID>BMHash(munge)
    1              0.000001   if s:bmenu_short == 0
    1              0.000004     let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
    1              0.000001   else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
                              endif
                              " set 'cpo' to include the <CR>
    1              0.000005   let cpo_save = &cpo
    1              0.000006   set cpo&vim
    1              0.000139   exe name . ' :confirm b' . a:num . '<CR>'
    1              0.000009   let &cpo = cpo_save

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 6 times
Total time:   0.231827
 Self time:   0.000083

count  total (s)   self (s)
    6   0.231819   0.000075     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  airline#extensions#hunks#get_hunks()
Called 261 times
Total time:   0.294144
 Self time:   0.282044

count  total (s)   self (s)
  261              0.000759   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
  261   0.013398   0.001298   let hunks = s:get_hunks()
  261              0.000417   let string = ''
  261              0.000472   if !empty(hunks)
 1044              0.001676     for i in [0, 1, 2]
  783              0.001511       if s:non_zero_only == 0 || hunks[i] > 0
  783              0.004651         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  783              0.000714       endif
  783              0.267420     endfor
  261              0.000214   endif
  261              0.000326   return string

FUNCTION  <SNR>9_BMAdd()
Called 1 time
Total time:   0.000323
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002   if s:bmenu_wait == 0
                                " when adding too many buffers, redraw in short format
    1              0.000002     if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                  call s:BMShow()
                                else
    1   0.000307   0.000012       call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
    1              0.000005       let s:bmenu_count = s:bmenu_count + 1
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  294()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000008     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  295()
Called 2 times
Total time:   0.000155
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000016   0.000008     call self.setOwner(bufnr(''))
    2   0.000048   0.000010     let self._stamp = syntastic#util#stamp()
    4   0.000076   0.000011     for buf in self.getBuffers()
    2              0.000008         call setbufvar(buf, 'syntastic_loclist', self)
    2              0.000002     endfor

FUNCTION  296()
Called 2 times
Total time:   0.000101
 Self time:   0.000025

count  total (s)   self (s)
    4   0.000087   0.000011     for buf in self.getBuffers()
    2              0.000007         call setbufvar(buf, 'syntastic_loclist', {})
    2              0.000002     endfor

FUNCTION  <SNR>49__resolve_filetypes()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000008     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    2              0.000012     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  gitgutter#utility#is_active()
Called 28 times
Total time:   0.001016
 Self time:   0.000226

count  total (s)   self (s)
   28   0.000995   0.000205   return g:gitgutter_enabled && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  SyntasticStatuslineFlag()
Called 473 times
Total time:   0.038420
 Self time:   0.003698

count  total (s)   self (s)
  473   0.038177   0.003455     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  gitgutter#diff#is_removed()
Called 195 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
  195              0.000320   return a:from_count > 0 && a:to_count == 0

FUNCTION  135()
Called 57 times
Total time:   0.041792
 Self time:   0.012998

count  total (s)   self (s)
   57   0.009726   0.000182     if a:path.equals(self.path)
    3              0.000005         return self
                                endif
   54   0.008634   0.000360     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   42              0.000044         return {}
                                endif
                            
   12              0.000017     if self.path.isDirectory
   69              0.000110         for i in self.children
   69   0.003391   0.000255             let retVal = i.findNode(a:path)
   69              0.000094             if retVal != {}
   12              0.000014                 return retVal
                                        endif
   57              0.000047         endfor
                                endif
                                return {}

FUNCTION  <SNR>49_CacheErrors()
Called 2 times
Total time:   0.001674
 Self time:   0.000367

count  total (s)   self (s)
    2   0.000025   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    2   0.000624   0.000008     call s:ClearCache()
    2   0.000072   0.000011     let newLoclist = g:SyntasticLoclist.New([])
                            
    2   0.000136   0.000007     if !s:_skip_file()
                                    " debug logging {{{3
    2   0.000022   0.000008         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    2   0.000028   0.000016         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    2   0.000022   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    2   0.000034   0.000013         let filetypes = s:_resolve_filetypes([])
    2   0.000030   0.000014         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    2              0.000005         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    2              0.000004         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    2              0.000002         let clist = []
    4              0.000006         for type in filetypes
    2   0.000163   0.000013             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    2              0.000002         endfor
                            
    2              0.000003         let names = []
    2              0.000003         let unavailable_checkers = 0
    4              0.000005         for checker in clist
    2   0.000021   0.000014             let cname = checker.getFiletype() . '/' . checker.getName()
    2   0.000076   0.000008             if !checker.isAvailable()
    2   0.000024   0.000011                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    2              0.000004                 let unavailable_checkers += 1
    2              0.000004                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    2              0.000002         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    2              0.000004         if len(clist) == unavailable_checkers
    2              0.000003             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
    2   0.000023   0.000011                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    2              0.000001             endif
    2              0.000000         endif
                                    " }}}3
                            
    2   0.000018   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    2              0.000003         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    2              0.000001     endif
                            
    2   0.000161   0.000006     call newLoclist.deploy()

FUNCTION  gitgutter#hunk#set_hunks()
Called 18 times
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
   18              0.000346   let s:hunks = a:hunks

FUNCTION  airline#builder#new()
Called 47 times
Total time:   0.001412
 Self time:   0.001412

count  total (s)   self (s)
   47              0.000351   let builder = copy(s:prototype)
   47              0.000138   let builder._context = a:context
   47              0.000107   let builder._sections = []
                            
   47              0.000646   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   47              0.000073   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   28   1.232440   0.002860  gitgutter#process_buffer()
   20   1.096176   0.004023  gitgutter#diff#run_diff()
   21   1.090305   0.002460  gitgutter#utility#system()
  551   1.032039   0.517829  airline#check_mode()
   39   0.735447   0.149151  airline#highlighter#highlight()
    6   0.734434   0.001017  gitgutter#all()
  645   0.570628   0.213112  <SNR>79_exec_separator()
 1574   0.356101   0.257008  airline#highlighter#get_highlight()
 1290   0.335478   0.007203  airline#themes#get_highlight()
  261   0.294144   0.282044  airline#extensions#hunks#get_hunks()
    6   0.231827   0.000083  nerdtree#ui_glue#invokeKeyMap()
    6   0.231744   0.000480  74()
    1   0.230376   0.000028  <SNR>51_on_colorscheme_changed()
    1   0.230213   0.000059  airline#load_theme()
    1   0.224154   0.000038  airline#highlighter#load_theme()
    6   0.206529   0.000131  73()
    2   0.183474   0.000028  <SNR>36_activateFileNode()
    2   0.183446   0.000042  102()
    2   0.183404   0.000035  119()
    2   0.183264   0.000023  169()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  551   1.032039   0.517829  airline#check_mode()
  261   0.294144   0.282044  airline#extensions#hunks#get_hunks()
 1574   0.356101   0.257008  airline#highlighter#get_highlight()
  645   0.570628   0.213112  <SNR>79_exec_separator()
   39   0.735447   0.149151  airline#highlighter#highlight()
  473   0.130867   0.122153  airline#extensions#whitespace#check()
 2879              0.090166  airline#highlighter#exec()
 3148              0.082060  <SNR>79_get_syn()
   18   0.045667   0.045633  gitgutter#sign#find_current_signs()
  211              0.038576  <SNR>62_Highlight_Matching_Pair()
  473              0.029679  289()
   47   0.130114   0.025617  347()
 1892              0.019838  airline#util#append()
   18   0.022699   0.018944  gitgutter#sign#upsert_new_gitgutter_signs()
 1574              0.017033  <SNR>79_get_array()
 3007              0.016879  airline#util#wrap()
  285   0.027362   0.015347  gitgutter#diff#process_hunk()
   57   0.041792   0.012998  135()
  287   0.022590   0.011306  38()
  286              0.011041  gitgutter#diff#parse_hunk()

